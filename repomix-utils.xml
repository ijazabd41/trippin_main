This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/utils/**/*.{js,jsx,ts,tsx}, src/hooks/**/*.{js,jsx,ts,tsx}, src/config/**/*.{js,jsx,ts,tsx}, src/contexts/**/*.{js,jsx,ts,tsx}
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  config/
    api.ts
    vercel-api.ts
  contexts/
    AuthContext.tsx
    LanguageContext.tsx
    NotificationContext.tsx
    TripContext.tsx
  hooks/
    usePWA.ts
  utils/
    apiMockData.ts
    errorHandler.ts
    imageOptimizer.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/config/api.ts">
// Vercel API configuration for TRIPPIN
export const API_CONFIG = {
  BASE_URL: import.meta.env.VITE_API_BASE_URL || 'https://your-app.vercel.app/api',
  ENDPOINTS: {
    OPENAI_CHAT: '/openai-chat',
    OPENAI_VISION: '/openai-vision', 
    OPENAI_GENERATE: '/openai-generate',
    TRIPADVISOR: '/tripadvisor',
    GOOGLE_MAPS: '/google-maps',
    GOOGLE_PLACES: '/google-places',
    ESIM: '/esim',
    AMADEUS: '/amadeus',
    CURRENCY_CONVERT: '/currency-convert',
    CREATE_CHECKOUT: '/create-checkout-session',
    VERIFY_PAYMENT: '/verify-payment'
  },
  TIMEOUT: 30000, // 30 seconds
  RETRY_ATTEMPTS: 3,
  RETRY_DELAY: 1000 // 1 second
};

// Helper function to build API URLs
export const buildApiUrl = (endpoint: string, params?: Record<string, string>): string => {
  const url = new URL(`${API_CONFIG.BASE_URL}${endpoint}`);
  
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        url.searchParams.append(key, value);
      }
    });
  }
  
  return url.toString();
};

// Enhanced error types
export interface APIError extends Error {
  status?: number;
  code?: string;
  details?: any;
  endpoint?: string;
  retryable?: boolean;
}

// Create custom error
const createAPIError = (message: string, status?: number, code?: string, endpoint?: string): APIError => {
  const error = new Error(message) as APIError;
  error.status = status;
  error.code = code;
  error.endpoint = endpoint;
  error.retryable = status ? [408, 429, 500, 502, 503, 504].includes(status) : false;
  return error;
};

// Sleep function for retry delays
const sleep = (ms: number): Promise<void> => new Promise(resolve => setTimeout(resolve, ms));

// Enhanced retry logic with exponential backoff
const retryWithBackoff = async <T>(
  operation: () => Promise<T>,
  maxAttempts: number = API_CONFIG.RETRY_ATTEMPTS,
  baseDelay: number = API_CONFIG.RETRY_DELAY
): Promise<T> => {
  let lastError: APIError;
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as APIError;
      
      // Don't retry if error is not retryable
      if (!lastError.retryable || attempt === maxAttempts) {
        throw lastError;
      }
      
      // Exponential backoff: 1s, 2s, 4s, 8s...
      const delay = baseDelay * Math.pow(2, attempt - 1);
      console.warn(`API call failed (attempt ${attempt}/${maxAttempts}), retrying in ${delay}ms...`, {
        error: lastError.message,
        endpoint: lastError.endpoint,
        status: lastError.status
      });
      
      await sleep(delay);
    }
  }
  
  throw lastError!;
};

// Network status checker
export const checkNetworkStatus = (): boolean => {
  return navigator.onLine;
};

// Enhanced API call function with comprehensive error handling
import { getMockDataByEndpoint } from '../utils/apiMockData';

export const apiCall = async (endpoint: string, options: RequestInit = {}): Promise<any> => {
  // Check network connectivity
  if (!checkNetworkStatus()) {
    throw createAPIError(
      'ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šãŒã‚ã‚Šã¾ã›ã‚“ã€‚æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
      0,
      'NETWORK_OFFLINE',
      endpoint
    );
  }

  const url = `${API_CONFIG.BASE_URL}${endpoint}`;
  
  const defaultHeaders = {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
    ...options.headers
  };

  const requestOptions: RequestInit = {
    ...options,
    headers: defaultHeaders,
    timeout: API_CONFIG.TIMEOUT
  };

  console.log(`ğŸš€ API Request: ${options.method || 'GET'} ${url}`, {
    endpoint,
    headers: defaultHeaders,
    body: options.body ? JSON.parse(options.body as string) : undefined
  });

  const makeRequest = async (): Promise<any> => {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.TIMEOUT);

    try {
      const response = await fetch(url, {
        ...requestOptions,
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      console.log(`ğŸ“¡ API Response: ${response.status} ${response.statusText}`, {
        endpoint,
        status: response.status,
        headers: Object.fromEntries(response.headers.entries())
      });

      // Handle different response statuses
      if (!response.ok) {
        let errorMessage = `API Error: ${response.status} - ${response.statusText}`;
        let errorDetails: any = null;

        try {
          const errorData = await response.json();
          errorDetails = errorData;
          errorMessage = errorData.message || errorData.error || errorMessage;
        } catch (parseError) {
          // If response is not JSON, use status text
          console.warn('Failed to parse error response as JSON:', parseError);
        }

        // Create specific error based on status code
        switch (response.status) {
          case 400:
            throw createAPIError(
              `ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒç„¡åŠ¹ã§ã™: ${errorMessage}`,
              400,
              'BAD_REQUEST',
              endpoint
            );
          case 401:
            throw createAPIError(
              'èªè¨¼ãŒå¿…è¦ã§ã™ã€‚ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚',
              401,
              'UNAUTHORIZED',
              endpoint
            );
          case 403:
            throw createAPIError(
              'ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚æ¨©é™ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
              403,
              'FORBIDDEN',
              endpoint
            );
          case 404:
            throw createAPIError(
              'ãƒªã‚¯ã‚¨ã‚¹ãƒˆã•ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚',
              404,
              'NOT_FOUND',
              endpoint
            );
          case 408:
            throw createAPIError(
              'ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
              408,
              'REQUEST_TIMEOUT',
              endpoint
            );
          case 429:
            throw createAPIError(
              'ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒå¤šã™ãã¾ã™ã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰ãŠè©¦ã—ãã ã•ã„ã€‚',
              429,
              'RATE_LIMITED',
              endpoint
            );
          case 500:
            throw createAPIError(
              'ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰ãŠè©¦ã—ãã ã•ã„ã€‚',
              500,
              'INTERNAL_SERVER_ERROR',
              endpoint
            );
          case 502:
            throw createAPIError(
              'ã‚µãƒ¼ãƒãƒ¼ãŒä¸€æ™‚çš„ã«åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚',
              502,
              'BAD_GATEWAY',
              endpoint
            );
          case 503:
            throw createAPIError(
              'ã‚µãƒ¼ãƒ“ã‚¹ãŒä¸€æ™‚çš„ã«åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ä¸­ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚',
              503,
              'SERVICE_UNAVAILABLE',
              endpoint
            );
          case 504:
            throw createAPIError(
              'ã‚µãƒ¼ãƒãƒ¼ã®å¿œç­”ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚',
              504,
              'GATEWAY_TIMEOUT',
              endpoint
            );
          default:
            throw createAPIError(
              errorMessage,
              response.status,
              'UNKNOWN_ERROR',
              endpoint
            );
        }
      }

      // Parse response
      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
        const data = await response.json();
        console.log(`âœ… API Success:`, { endpoint, data });
        
        // Validate response structure for common endpoints
        if (endpoint.includes('/google-maps') || endpoint.includes('/google-places')) {
          if (data.predictions && !Array.isArray(data.predictions)) {
            console.warn(`[API] Invalid predictions format for ${endpoint}:`, data.predictions);
            data.predictions = [];
          }
          if (data.candidates && !Array.isArray(data.candidates)) {
            console.warn(`[API] Invalid candidates format for ${endpoint}:`, data.candidates);
            data.candidates = [];
          }
          if (data.data && !Array.isArray(data.data)) {
            console.warn(`[API] Invalid data format for ${endpoint}:`, data.data);
            data.data = [];
          }
        }
        
        // Validate OpenAI response structure
        if (endpoint.includes('/openai-')) {
          if (data.response && typeof data.response !== 'string') {
            console.warn(`[API] Invalid response format for ${endpoint}:`, data.response);
            data.response = '';
          }
          if (data.translation && typeof data.translation !== 'string') {
            console.warn(`[API] Invalid translation format for ${endpoint}:`, data.translation);
            data.translation = '';
          }
        }
        
        return data;
      } else {
        const text = await response.text();
        console.log(`âœ… API Success (text):`, { endpoint, text });
        return { data: text };
      }

    } catch (error) {
      clearTimeout(timeoutId);

      if (error.name === 'AbortError') {
        throw createAPIError(
          'ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
          408,
          'TIMEOUT',
          endpoint
        );
      }

      if (error instanceof TypeError && error.message.includes('fetch')) {
        throw createAPIError(
          'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
          0,
          'NETWORK_ERROR',
          endpoint
        );
      }

      // Re-throw API errors as-is
      if ((error as APIError).status !== undefined) {
        // Try to provide mock data for certain endpoints
        const mockData = getMockDataByEndpoint(endpoint);
        if (mockData.success) {
          console.warn(`[API] Using mock data for ${endpoint}:`, mockData.message);
          return mockData;
        }
        throw error;
      }

      // Handle unknown errors
      // Try to provide mock data as last resort
      const mockData = getMockDataByEndpoint(endpoint);
      if (mockData.success) {
        console.warn(`[API] Using mock data for ${endpoint}:`, mockData.message);
        return mockData;
      }
      
      throw createAPIError(
        `äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`,
        0,
        'UNKNOWN_ERROR',
        endpoint
      );
    }
  };

  // Execute with retry logic
  try {
    return await retryWithBackoff(makeRequest);
  } catch (error) {
    const apiError = error as APIError;
    
    // Try to provide mock data before throwing error
    const mockData = getMockDataByEndpoint(endpoint);
    if (mockData.success) {
      console.warn(`[API] Using mock data for ${endpoint}:`, mockData.message);
      return mockData;
    }
    
    // Log error for debugging
    console.error(`âŒ API Error (${endpoint}):`, {
      message: apiError.message,
      status: apiError.status,
      code: apiError.code,
      endpoint: apiError.endpoint,
      retryable: apiError.retryable
    });

    // Add user-friendly fallback messages
    if (apiError.code === 'NETWORK_OFFLINE') {
      apiError.message = 'ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã§ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
    } else if (apiError.code === 'NETWORK_ERROR') {
      apiError.message = 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æ¥ç¶šã‚’ç¢ºèªã—ã¦ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚';
    }

    throw apiError;
  }
};

// Specialized API calls for different services
export const openAICall = async (endpoint: string, data: any): Promise<any> => {
  return apiCall(endpoint, {
    method: 'POST',
    body: JSON.stringify(data)
  });
};

export const googleMapsCall = async (params: Record<string, string>): Promise<any> => {
  return apiCall(buildApiUrl(API_CONFIG.ENDPOINTS.GOOGLE_MAPS, params));
};

export const tripAdvisorCall = async (params: Record<string, string>): Promise<any> => {
  return apiCall(buildApiUrl(API_CONFIG.ENDPOINTS.TRIPADVISOR, params));
};

export const esimCall = async (data?: any): Promise<any> => {
  if (data) {
    return apiCall(API_CONFIG.ENDPOINTS.ESIM, {
      method: 'POST',
      body: JSON.stringify(data)
    });
  }
  return apiCall(API_CONFIG.ENDPOINTS.ESIM);
};

export const stripeCall = async (endpoint: string, data: any): Promise<any> => {
  return apiCall(endpoint, {
    method: 'POST',
    body: JSON.stringify(data)
  });
};

// Health check function
export const healthCheck = async (): Promise<boolean> => {
  try {
    const response = await fetch(`${API_CONFIG.BASE_URL}/health`, {
      method: 'GET',
      timeout: 5000
    });
    return response.ok;
  } catch (error) {
    console.error('Health check failed:', error);
    return false;
  }
};

// Service status checker
export const checkServiceStatus = async (): Promise<{
  api: boolean;
  openai: boolean;
  maps: boolean;
  stripe: boolean;
}> => {
  const status = {
    api: false,
    openai: false,
    maps: false,
    stripe: false
  };

  try {
    status.api = await healthCheck();
  } catch (error) {
    console.error('API health check failed:', error);
  }

  return status;
};
</file>

<file path="src/config/vercel-api.ts">
// Vercelç”¨ã®APIè¨­å®š
export const vercelConfig = {
  // Vercel Functionsç”¨ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
  apiBaseUrl: process.env.NODE_ENV === 'production' 
    ? 'https://your-app.vercel.app/api'
    : 'http://localhost:3000/api',
  
  // ç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—
  auth0: {
    domain: import.meta.env.VITE_AUTH0_DOMAIN,
    clientId: import.meta.env.VITE_AUTH0_CLIENT_ID,
    callbackUrl: import.meta.env.VITE_AUTH0_CALLBACK_URL,
  },
  
  stripe: {
    publishableKey: import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY,
  },
  
  app: {
    name: import.meta.env.VITE_APP_NAME || 'Trippin',
    version: import.meta.env.VITE_APP_VERSION || '1.0.0',
  }
};

// APIå‘¼ã³å‡ºã—ç”¨ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
export const apiCall = async (endpoint: string, options: RequestInit = {}) => {
  const url = `${vercelConfig.apiBaseUrl}${endpoint}`;
  
  const response = await fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });
  
  if (!response.ok) {
    throw new Error(`API Error: ${response.status} ${response.statusText}`);
  }
  
  return response.json();
};

// èªè¨¼ä»˜ãAPIå‘¼ã³å‡ºã—
export const authenticatedApiCall = async (
  endpoint: string, 
  token: string, 
  options: RequestInit = {}
) => {
  return apiCall(endpoint, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`,
    },
  });
};
</file>

<file path="src/contexts/AuthContext.tsx">
// AuthContext.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { Auth0Provider, useAuth0, AppState } from '@auth0/auth0-react';
import { useNavigate } from 'react-router-dom';

interface User {
  id: string;
  email: string;
  name: string;
  avatar?: string;
  isPremium?: boolean;
}

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isPremium: boolean;
  login: (connection?: string) => Promise<void>;
  logout: () => void;
  register: () => Promise<void>;
  upgradeToPremiun: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const auth0 = useAuth0();
  const [user, setUser] = useState<User | null>(null);
  const [isPremium, setIsPremium] = useState(false);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  const login = async (connection?: string) => {
    try {
      console.log('[AuthContext] Login attempt with connection:', connection);
      console.log('[AuthContext] Auth0 config:', {
        domain: import.meta.env.VITE_AUTH0_DOMAIN,
        clientId: import.meta.env.VITE_AUTH0_CLIENT_ID,
        isLoading: auth0.isLoading,
        isAuthenticated: auth0.isAuthenticated
      });
      
      const options: any = {
        appState: { returnTo: '/checkout' } as AppState
      };
      
      if (connection) {
        options.connection = connection;
        options.authorizationParams = {
          connection: connection
        };
      }
      
      console.log('[AuthContext] Calling loginWithRedirect with options:', options);
      await auth0.loginWithRedirect(options);
    } catch (error) {
      console.error('Login failed:', error);
      throw error;
    }
  };

  const logout = () => {
    auth0.logout({ logoutParams: { returnTo: window.location.origin } });
  };

  const register = async () => {
    try {
      // Get current path to return to after registration
      const returnTo = '/checkout';
        
      await auth0.loginWithRedirect({
        authorizationParams: {
          screen_hint: 'signup',
        },
        appState: { returnTo }
      });
    } catch (error) {
      console.error('Registration failed:', error);
      throw error;
    }
  };

  const upgradeToPremiun = async () => {
    if (user) {
      const updatedUser = { ...user, isPremium: true };
      setUser(updatedUser);
      setIsPremium(true);
      localStorage.setItem('trippin-user', JSON.stringify(updatedUser));
      return Promise.resolve();
    }
    return Promise.reject(new Error('User not authenticated'));
  };

  useEffect(() => {
    if (auth0.isLoading) return;

    if (auth0.isAuthenticated && auth0.user) {
      const savedUserData = localStorage.getItem('trippin-user');
      const savedUser = savedUserData ? JSON.parse(savedUserData) : null;

      const newUser: User = {
        id: auth0.user.sub || '1',
        email: auth0.user.email || '',
        name: auth0.user.name || auth0.user.nickname || auth0.user.email?.split('@')[0] || '',
        avatar: auth0.user.picture,
        isPremium: savedUser?.isPremium || false
      };

      setUser(newUser);
      setIsPremium(savedUser?.isPremium || false);
      setIsAuthenticated(true);
      localStorage.setItem('trippin-user', JSON.stringify(newUser));
    } else {
      setUser(null);
      setIsAuthenticated(false);
    }
  }, [auth0.isLoading, auth0.isAuthenticated, auth0.user]);

  return (
    <AuthContext.Provider value={{ user, isAuthenticated, login, logout, register, upgradeToPremiun, isPremium }}>
      {children}
    </AuthContext.Provider>
  );
};

// Auth0ProviderWithHistory.tsx
export const Auth0ProviderWithHistory: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const navigate = useNavigate();
  const domain = import.meta.env.VITE_AUTH0_DOMAIN;
  const clientId = import.meta.env.VITE_AUTH0_CLIENT_ID;
  const audience = import.meta.env.VITE_AUTH0_AUDIENCE;

  if (!domain || !clientId) {
    throw new Error('Auth0 domain or client ID not provided');
  }

  const onRedirectCallback = (appState?: AppState) => {
    const returnTo = appState?.returnTo || '/checkout';
    console.log('[Auth0] Redirecting to:', returnTo);
    navigate(returnTo);
  };
  return (
    <Auth0Provider
      domain={domain}
      clientId={clientId}
      audience={audience}
      authorizationParams={{
        redirect_uri: window.location.origin,
      }}
      onRedirectCallback={onRedirectCallback}
    >
      {children}
    </Auth0Provider>
  );
};
</file>

<file path="src/contexts/LanguageContext.tsx">
import React, { createContext, useContext, useState, useEffect } from 'react';
import i18n from '../i18n/config';
import { validateTranslations } from '../i18n/config';

interface LanguageContextType {
  currentLanguage: string;
  changeLanguage: (lang: string) => void;
  t: (key: string) => string;
  validateTranslation: (key: string) => boolean;
}

const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

export const useLanguage = () => {
  const context = useContext(LanguageContext);
  if (!context) {
    throw new Error('useLanguage must be used within a LanguageProvider');
  }
  return context;
};

export const LanguageProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [currentLanguage, setCurrentLanguage] = useState('ja');

  const changeLanguage = (lang: string) => {
    setCurrentLanguage(lang);
    i18n.changeLanguage(lang);
    localStorage.setItem('trippin-language', lang);
  };

  const t = (key: string) => {
    const translation = i18n.t(key);
    
    // In development, show error for missing translations
    if (process.env.NODE_ENV === 'development') {
      if (translation === key || !translation || translation.includes('[MISSING:')) {
        console.error(`âŒ Translation missing: "${key}" for language "${currentLanguage}"`);
        return `[MISSING: ${key}]`;
      }
    }
    
    return translation;
  };

  const validateTranslation = (key: string): boolean => {
    const translation = i18n.t(key);
    return translation !== key && translation && !translation.includes('[MISSING:');
  };

  useEffect(() => {
    const savedLanguage = localStorage.getItem('trippin-language') || 'ja';
    changeLanguage(savedLanguage);
  }, []);

  return (
    <LanguageContext.Provider value={{ currentLanguage, changeLanguage, t, validateTranslation }}>
      {children}
    </LanguageContext.Provider>
  );
};
</file>

<file path="src/contexts/NotificationContext.tsx">
import React, { createContext, useContext, useState, useEffect } from 'react';

interface Notification {
  id: string;
  type: 'info' | 'success' | 'warning' | 'error';
  title: string;
  message: string;
  timestamp: string;
  read: boolean;
  actions?: Array<{
    label: string;
    action: () => void;
  }>;
}

interface NotificationContextType {
  notifications: Notification[];
  unreadCount: number;
  addNotification: (notification: Omit<Notification, 'id' | 'timestamp' | 'read'>) => void;
  markAsRead: (notificationId: string) => void;
  markAllAsRead: () => void;
  removeNotification: (notificationId: string) => void;
  clearAllNotifications: () => void;
}

const NotificationContext = createContext<NotificationContextType | undefined>(undefined);

export const useNotification = () => {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error('useNotification must be used within a NotificationProvider');
  }
  return context;
};

export const NotificationProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [notifications, setNotifications] = useState<Notification[]>([]);

  const addNotification = (notification: Omit<Notification, 'id' | 'timestamp' | 'read'>) => {
    const newNotification: Notification = {
      ...notification,
      id: `notification_${Date.now()}`,
      timestamp: new Date().toISOString(),
      read: false,
    };

    setNotifications(prev => [newNotification, ...prev]);
  };

  const markAsRead = (notificationId: string) => {
    setNotifications(prev =>
      prev.map(notification =>
        notification.id === notificationId
          ? { ...notification, read: true }
          : notification
      )
    );
  };

  const markAllAsRead = () => {
    setNotifications(prev =>
      prev.map(notification => ({ ...notification, read: true }))
    );
  };

  const removeNotification = (notificationId: string) => {
    setNotifications(prev =>
      prev.filter(notification => notification.id !== notificationId)
    );
  };

  const clearAllNotifications = () => {
    setNotifications([]);
  };

  const unreadCount = notifications.filter(n => !n.read).length;

  useEffect(() => {
    const savedNotifications = localStorage.getItem('trippin-notifications');
    if (savedNotifications) {
      setNotifications(JSON.parse(savedNotifications));
    }
  }, []);

  useEffect(() => {
    localStorage.setItem('trippin-notifications', JSON.stringify(notifications));
  }, [notifications]);

  return (
    <NotificationContext.Provider value={{
      notifications,
      unreadCount,
      addNotification,
      markAsRead,
      markAllAsRead,
      removeNotification,
      clearAllNotifications
    }}>
      {children}
    </NotificationContext.Provider>
  );
};
</file>

<file path="src/contexts/TripContext.tsx">
import React, { createContext, useContext, useState, useEffect } from 'react';
import { apiCall, API_CONFIG } from '../config/api';

interface Trip {
  id: string;
  title: string;
  destination: string;
  startDate: string;
  endDate: string;
  status: 'planning' | 'upcoming' | 'ongoing' | 'completed';
  itinerary: any[];
  budget: number;
  currency: string;
  travelers: number;
  interests: string[];
  createdAt: string;
  updatedAt: string;
}

interface TripContextType {
  trips: Trip[];
  currentTrip: Trip | null;
  createTrip: (tripData: Partial<Trip>) => Promise<Trip>;
  updateTrip: (tripId: string, updates: Partial<Trip>) => Promise<void>;
  deleteTrip: (tripId: string) => Promise<void>;
  setCurrentTrip: (trip: Trip | null) => void;
  generateItinerary: (tripData: any) => Promise<any>;
  shareTrip: (tripId: string, shareData: any) => Promise<string>;
}

const TripContext = createContext<TripContextType | undefined>(undefined);

export const useTrip = () => {
  const context = useContext(TripContext);
  if (!context) {
    throw new Error('useTrip must be used within a TripProvider');
  }
  return context;
};

export const TripProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [trips, setTrips] = useState<Trip[]>([]);
  const [currentTrip, setCurrentTrip] = useState<Trip | null>(null);

  const createTrip = async (tripData: Partial<Trip>): Promise<Trip> => {
    const newTrip: Trip = {
      id: `trip_${Date.now()}`,
      title: tripData.title || 'æ–°ã—ã„æ—…è¡Œ',
      destination: tripData.destination || '',
      startDate: tripData.startDate || '',
      endDate: tripData.endDate || '',
      status: 'planning',
      itinerary: tripData.itinerary || [],
      budget: tripData.budget || 0,
      currency: tripData.currency || 'JPY',
      travelers: tripData.travelers || 1,
      interests: tripData.interests || [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      image: tripData.image || 'https://images.pexels.com/photos/2070033/pexels-photo-2070033.jpeg'
    };

    setTrips(prev => [...prev, newTrip]);
    localStorage.setItem('trippin-trips', JSON.stringify([...trips, newTrip]));
    
    return newTrip;
  };

  const updateTrip = async (tripId: string, updates: Partial<Trip>): Promise<void> => {
    const updatedTrips = trips.map(trip => 
      trip.id === tripId 
        ? { ...trip, ...updates, updatedAt: new Date().toISOString() }
        : trip
    );
    
    setTrips(updatedTrips);
    localStorage.setItem('trippin-trips', JSON.stringify(updatedTrips));
    
    if (currentTrip?.id === tripId) {
      setCurrentTrip({ ...currentTrip, ...updates, updatedAt: new Date().toISOString() });
    }
  };

  const deleteTrip = async (tripId: string): Promise<void> => {
    const filteredTrips = trips.filter(trip => trip.id !== tripId);
    setTrips(filteredTrips);
    localStorage.setItem('trippin-trips', JSON.stringify(filteredTrips));
    
    if (currentTrip?.id === tripId) {
      setCurrentTrip(null);
    }
  };

  const generateItinerary = async (tripData: any): Promise<any> => {
    try {
      const result = await apiCall(API_CONFIG.ENDPOINTS.OPENAI_GENERATE, {
        method: 'POST',
        body: JSON.stringify({ tripData })
      });


      return result.data;
    } catch (error) {
      console.error('Error generating itinerary:', error);
      throw error;
    }
  };

  const shareTrip = async (tripId: string, shareData: any): Promise<string> => {
    // Generate shareable link
    const shareId = `share_${Date.now()}`;
    const shareUrl = `${window.location.origin}/share/${shareId}`;
    
    // Store share data
    localStorage.setItem(`trippin-share-${shareId}`, JSON.stringify({
      tripId,
      ...shareData,
      createdAt: new Date().toISOString()
    }));
    
    return shareUrl;
  };

  useEffect(() => {
    const savedTrips = localStorage.getItem('trippin-trips');
    if (savedTrips) {
      setTrips(JSON.parse(savedTrips));
    }
  }, []);

  return (
    <TripContext.Provider value={{
      trips,
      currentTrip,
      createTrip,
      updateTrip,
      deleteTrip,
      setCurrentTrip,
      generateItinerary,
      shareTrip
    }}>
      {children}
    </TripContext.Provider>
  );
};
</file>

<file path="src/hooks/usePWA.ts">
import { useState, useEffect } from 'react';

interface PWAInstallPrompt {
  prompt: () => Promise<void>;
  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>;
}

interface PWAHookReturn {
  isInstallable: boolean;
  isInstalled: boolean;
  isOnline: boolean;
  installApp: () => Promise<boolean>;
  updateAvailable: boolean;
  updateApp: () => void;
}

export const usePWA = (): PWAHookReturn => {
  const [isInstallable, setIsInstallable] = useState(false);
  const [isInstalled, setIsInstalled] = useState(false);
  const [isServiceWorkerSupported, setIsServiceWorkerSupported] = useState(false);
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [installPrompt, setInstallPrompt] = useState<PWAInstallPrompt | null>(null);
  const [updateAvailable, setUpdateAvailable] = useState(false);
  const [registration, setRegistration] = useState<ServiceWorkerRegistration | null>(null);

  useEffect(() => {
    // Check if Service Workers are supported and not in StackBlitz
    const isSupported = 'serviceWorker' in navigator && 
                       !window.location.hostname.includes('stackblitz') &&
                       !window.location.hostname.includes('webcontainer');
    
    setIsServiceWorkerSupported(isSupported);

    // Check if app is already installed
    const checkInstalled = () => {
      const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
      const isInWebAppiOS = (window.navigator as any).standalone === true;
      setIsInstalled(isStandalone || isInWebAppiOS);
    };

    checkInstalled();

    // Listen for install prompt
    const handleBeforeInstallPrompt = (e: Event) => {
      e.preventDefault();
      setInstallPrompt(e as any);
      setIsInstallable(true);
      console.log('[PWA] Install prompt available');
    };

    // Listen for app installed
    const handleAppInstalled = () => {
      setIsInstalled(true);
      setIsInstallable(false);
      setInstallPrompt(null);
      console.log('[PWA] App installed successfully');
    };

    // Listen for online/offline status
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    // Register service worker
    const registerServiceWorker = async () => {
      if ('serviceWorker' in navigator) {
        try {
          const reg = await navigator.serviceWorker.register('/sw.js');
          setRegistration(reg);
          console.log('[PWA] Service worker registered');

          // Check for updates
          reg.addEventListener('updatefound', () => {
            const newWorker = reg.installing;
            if (newWorker) {
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  setUpdateAvailable(true);
                  console.log('[PWA] Update available');
                }
              });
            }
          });
        } catch (error) {
          console.error('[PWA] Service worker registration failed:', error);
        }
      }
    };

    // Add event listeners
    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    window.addEventListener('appinstalled', handleAppInstalled);
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    // Register service worker
    if (isSupported) {
      registerServiceWorker();
    }

    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
      window.removeEventListener('appinstalled', handleAppInstalled);
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  const installApp = async (): Promise<boolean> => {
    if (!installPrompt) {
      console.warn('[PWA] No install prompt available');
      return false;
    }
  // Additional check to prevent registration in unsupported environments
  if ('serviceWorker' in navigator && 
      !window.location.hostname.includes('stackblitz') &&
      !window.location.hostname.includes('webcontainer')) {
    try {
      await installPrompt.prompt();
      const choiceResult = await installPrompt.userChoice;
      
      if (choiceResult.outcome === 'accepted') {
        console.log('[PWA] User accepted install');
        setIsInstallable(false);
        setInstallPrompt(null);
        return true;
      } else {
        console.log('[PWA] User dismissed install');
        return false;
      }
    } catch (error) {
      console.error('[PWA] Install failed:', error);
      return false;
    }
  } else {
    console.log('Service Worker not supported in this environment');
    return false;
  }
  };

  const updateApp = () => {
    if (registration && registration.waiting) {
      registration.waiting.postMessage({ type: 'SKIP_WAITING' });
      window.location.reload();
    }
  };

  return {
    isInstallable,
    isServiceWorkerSupported,
    isInstalled,
    isOnline,
    installApp,
    updateAvailable,
    updateApp
  };
};
</file>

<file path="src/utils/apiMockData.ts">
// Mock data for API fallbacks when services are unavailable
export interface MockDataResponse {
  success: boolean;
  data: any;
  isMockData: boolean;
  message: string;
}

// OpenAI Chat Mock Data
export const mockChatResponse = (): MockDataResponse => ({
  success: true,
  data: {
    response: "ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ãŒã€ç¾åœ¨AIã‚µãƒ¼ãƒ“ã‚¹ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚ã“ã¡ã‚‰ã¯äº‹å‰ã«æº–å‚™ã•ã‚ŒãŸå›ç­”ã§ã™ã€‚æ—¥æœ¬æ—…è¡Œã«ã¤ã„ã¦åŸºæœ¬çš„ãªæƒ…å ±ã‚’ãŠæ‰‹ä¼ã„ã§ãã¾ã™ã€‚"
  },
  isMockData: true,
  message: "é€šä¿¡ã«å¤±æ•—ã—ãŸãŸã‚ã€ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚"
});

// OpenAI Vision Mock Data
export const mockVisionResponse = (): MockDataResponse => ({
  success: true,
  data: {
    translation: "ç”»åƒç¿»è¨³ã‚µãƒ¼ãƒ“ã‚¹ãŒç¾åœ¨åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚"
  },
  isMockData: true,
  message: "é€šä¿¡ã«å¤±æ•—ã—ãŸãŸã‚ã€ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚"
});

// OpenAI Generate Mock Data
export const mockGenerateResponse = (): MockDataResponse => {
  const plans = [
    {
      theme: "æ–‡åŒ–ãƒ»æ­´å²é‡è¦–ãƒ—ãƒ©ãƒ³",
      description: "ä¼çµ±çš„ãªå¯ºé™¢ã¨æ­´å²çš„å»ºé€ ç‰©ã‚’ä¸­å¿ƒã¨ã—ãŸæ–‡åŒ–ä½“é¨“",
      destination: "æ±äº¬",
      duration: "3æ—¥é–“",
      totalEstimatedCost: "Â¥85,000",
      itinerary: [
        {
          day: 1,
          date: new Date().toISOString().split('T')[0],
          title: "æ±äº¬åˆ°ç€ãƒ»æµ…è‰æ–‡åŒ–æ¢ç´¢",
          activities: [
            {
              id: "cultural_act_1",
              time: "10:00",
              name: "ç¾½ç”°ç©ºæ¸¯åˆ°ç€",
              location: "ç¾½ç”°ç©ºæ¸¯",
              coordinates: { lat: 35.5494, lng: 139.7798 },
              type: "transport",
              description: "æ±äº¬ã¸ã®ç„é–¢å£ã€å›½éš›ç·šã‚¿ãƒ¼ãƒŸãƒŠãƒ«",
              estimatedCost: "0 JPY",
              duration: "30",
              rating: 4.0,
              tips: "åˆ°ç€å¾Œã€äº¬æ€¥ç·šã§æµ…è‰æ–¹é¢ã¸å‘ã‹ã„ã¾ã™ã€‚ICã‚«ãƒ¼ãƒ‰ã®è³¼å…¥ã‚’ãŠå¿˜ã‚Œãªãã€‚"
            },
            {
              id: "cultural_transport_1",
              time: "10:30",
              name: "ç¾½ç”°ç©ºæ¸¯ â†’ æµ…è‰é§…",
              location: "äº¬æ€¥ç·šãƒ»éƒ½å–¶æµ…è‰ç·š",
              coordinates: { lat: 35.7101, lng: 139.7956 },
              type: "transport",
              description: "äº¬æ€¥ç·šãƒ»éƒ½å–¶æµ…è‰ç·šã§æµ…è‰é§…ã¾ã§ç´„45åˆ†ã®é›»è»Šç§»å‹•",
              estimatedCost: "410 JPY",
              duration: "45",
              rating: 4.2,
              tips: "ICã‚«ãƒ¼ãƒ‰ï¼ˆSuica/PASMOï¼‰ãŒä¾¿åˆ©ã§ã™ã€‚ä¹—ã‚Šæ›ãˆã¯1å›ã§ã™ã€‚",
              transportDetails: {
                method: "é›»è»Š",
                line: "äº¬æ€¥ç·šâ†’éƒ½å–¶æµ…è‰ç·š",
                transfers: 1,
                walkingTime: "5åˆ†"
              }
            },
            {
              id: "cultural_act_2",
              time: "11:30",
              name: "æµ…è‰å¯ºå‚æ‹",
              location: "æµ…è‰",
              coordinates: { lat: 35.7148, lng: 139.7967 },
              type: "culture",
              description: "645å¹´å‰µå»ºã®æ±äº¬æœ€å¤ã®å¯ºé™¢ã€‚é›·é–€ï¼ˆé¢¨é›·ç¥é–€ï¼‰ã¯æµ…è‰ã®ã‚·ãƒ³ãƒœãƒ«ã§ã€é«˜ã•3.9mã€é‡ã•700kgã®å¤§æç¯ãŒæœ‰åã€‚æœ¬å ‚ã§ã¯è¦³éŸ³æ§˜ã«å‚æ‹ã—ã€ãŠã¿ãã˜ã‚’å¼•ãã“ã¨ãŒã§ãã¾ã™ã€‚",
              estimatedCost: "0 JPY",
              duration: "90",
              rating: 4.8,
              tips: "é›·é–€ã§ã®è¨˜å¿µæ’®å½±ã¯å¿…é ˆï¼æœ¬å ‚ã§ã®ãŠå‚ã‚Šã¯äºŒç¤¼äºŒæ‹æ‰‹ä¸€ç¤¼ã§ã€‚ãŠã¿ãã˜ã¯æ—¥æœ¬èªãƒ»è‹±èªå¯¾å¿œã§ã™ã€‚",
              reviews: [
                {
                  rating: 5,
                  text: "é›·é–€ã®è¿«åŠ›ã«åœ§å€’ã•ã‚Œã¾ã—ãŸã€‚æœ¬å ‚ã§ã®å‚æ‹ã¯å¿ƒãŒæ´—ã‚ã‚Œã‚‹æ€ã„ã§ã—ãŸã€‚",
                  author: "æ–‡åŒ–æ„›å¥½å®¶"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      theme: "ã‚°ãƒ«ãƒ¡ãƒ»é£Ÿã¹æ­©ããƒ—ãƒ©ãƒ³",
      description: "æ±äº¬ã®ç¾å‘³ã—ã„ã‚°ãƒ«ãƒ¡ã‚’ä¸­å¿ƒã¨ã—ãŸé£Ÿæ–‡åŒ–ä½“é¨“",
      destination: "æ±äº¬",
      duration: "3æ—¥é–“", 
      totalEstimatedCost: "Â¥95,000",
      itinerary: [
        {
          day: 1,
          date: new Date().toISOString().split('T')[0],
          title: "æ±äº¬åˆ°ç€ãƒ»ç¯‰åœ°ã‚°ãƒ«ãƒ¡æ¢ç´¢",
          activities: [
            {
              id: "gourmet_act_1",
              time: "10:00",
              name: "ç¾½ç”°ç©ºæ¸¯åˆ°ç€",
              location: "ç¾½ç”°ç©ºæ¸¯",
              coordinates: { lat: 35.5494, lng: 139.7798 },
              type: "transport",
              description: "æ±äº¬ã¸ã®ç„é–¢å£",
              estimatedCost: "0 JPY",
              duration: "30",
              rating: 4.0,
              tips: "åˆ°ç€å¾Œã€æ±äº¬ãƒ¢ãƒãƒ¬ãƒ¼ãƒ«ã§æ–°æ©‹çµŒç”±ç¯‰åœ°æ–¹é¢ã¸ã€‚"
            },
            {
              id: "gourmet_act_2",
              time: "11:30",
              name: "ç¯‰åœ°å ´å¤–å¸‚å ´",
              location: "ç¯‰åœ°",
              coordinates: { lat: 35.6654, lng: 139.7707 },
              type: "food",
              description: "æ–°é®®ãªæµ·é®®ã¨ã‚°ãƒ«ãƒ¡ã®è–åœ°ã€‚ãƒã‚°ãƒ­ã®è§£ä½“ã‚·ãƒ§ãƒ¼ã‚„è·äººã®æŠ€ã‚’é–“è¿‘ã§è¦‹å­¦ã§ãã¾ã™ã€‚",
              estimatedCost: "3500 JPY",
              duration: "120",
              rating: 4.7,
              tips: "æœæ—©ã„æ™‚é–“ï¼ˆ6:00-9:00ï¼‰ãŒæœ€ã‚‚æ´»æ°—ãŒã‚ã‚Šã¾ã™ã€‚ç‰å­ç„¼ãã®ã€Œå±±é•·ã€ã¯å¿…é£Ÿï¼"
            }
          ]
        }
      ]
    },
    {
      theme: "ç¾ä»£ã‚«ãƒ«ãƒãƒ£ãƒ¼ãƒ»ã‚¨ãƒ³ã‚¿ãƒ¡ãƒ—ãƒ©ãƒ³", 
      description: "æœ€æ–°ã®æ—¥æœ¬ãƒãƒƒãƒ—ã‚«ãƒ«ãƒãƒ£ãƒ¼ã¨ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ†ã‚¤ãƒ¡ãƒ³ãƒˆä½“é¨“",
      destination: "æ±äº¬",
      duration: "3æ—¥é–“",
      totalEstimatedCost: "Â¥78,000",
      itinerary: [
        {
          day: 1,
          date: new Date().toISOString().split('T')[0],
          title: "æ±äº¬åˆ°ç€ãƒ»ç§‹è‘‰åŸã‚¢ãƒ‹ãƒ¡æ–‡åŒ–",
          activities: [
            {
              id: "anime_act_1",
              time: "10:00",
              name: "ç¾½ç”°ç©ºæ¸¯åˆ°ç€",
              location: "ç¾½ç”°ç©ºæ¸¯",
              coordinates: { lat: 35.5494, lng: 139.7798 },
              type: "transport",
              description: "æ±äº¬ã¸ã®ç„é–¢å£",
              estimatedCost: "0 JPY",
              duration: "30",
              rating: 4.0,
              tips: "åˆ°ç€å¾Œã€äº¬æ€¥ç·šã§ç§‹è‘‰åŸæ–¹é¢ã¸ã€‚"
            },
            {
              id: "anime_act_2",
              time: "11:30",
              name: "ç§‹è‘‰åŸé›»æ°—è¡—",
              location: "ç§‹è‘‰åŸ",
              coordinates: { lat: 35.7022, lng: 139.7744 },
              type: "shopping",
              description: "ä¸–ç•Œæœ€å¤§ã®é›»æ°—è¡—ã€‚ã‚¢ãƒ‹ãƒ¡ã€ãƒãƒ³ã‚¬ã€ã‚²ãƒ¼ãƒ ã€ãƒ•ã‚£ã‚®ãƒ¥ã‚¢ãªã©ã‚ªã‚¿ã‚¯æ–‡åŒ–ã®è–åœ°ã€‚",
              estimatedCost: "5000 JPY",
              duration: "150",
              rating: 4.6,
              tips: "ãƒ¨ãƒ‰ãƒã‚·ã‚«ãƒ¡ãƒ©ã€ãƒ“ãƒƒã‚¯ã‚«ãƒ¡ãƒ©ã§æœ€æ–°ã‚¬ã‚¸ã‚§ãƒƒãƒˆã€‚ãƒ¡ã‚¤ãƒ‰ã‚«ãƒ•ã‚§ä½“é¨“ã‚‚ï¼"
            }
          ]
        }
      ]
    }
  ];

  return {
    success: true,
    data: {
      plans,
      itinerary: [
        {
          day: 1,
          date: new Date().toISOString().split('T')[0],
          title: "æ±äº¬åˆ°ç€ãƒ»æµ…è‰æ¢ç´¢",
          activities: [
            {
              id: "act_1",
              time: "10:00",
              name: "ç¾½ç”°ç©ºæ¸¯åˆ°ç€",
              location: "ç¾½ç”°ç©ºæ¸¯",
              coordinates: { lat: 35.5494, lng: 139.7798 },
              type: "transport",
              description: "æ±äº¬ã¸ã®ç„é–¢å£",
              estimatedCost: "0 JPY",
              duration: "30",
              rating: 4.0,
              tips: "åˆ°ç€å¾Œã€äº¬æ€¥ç·šã§æµ…è‰æ–¹é¢ã¸å‘ã‹ã„ã¾ã™ã€‚"
            },
            {
              id: "act_1_transport",
              time: "10:30",
              name: "ç¾½ç”°ç©ºæ¸¯ â†’ æµ…è‰é§…",
              location: "äº¬æ€¥ç·šãƒ»éƒ½å–¶æµ…è‰ç·š",
              coordinates: { lat: 35.7101, lng: 139.7956 },
              type: "transport",
              description: "äº¬æ€¥ç·šãƒ»éƒ½å–¶æµ…è‰ç·šã§æµ…è‰é§…ã¾ã§ç´„45åˆ†ã®é›»è»Šç§»å‹•",
              estimatedCost: "410 JPY",
              duration: "45",
              rating: 4.2,
              tips: "IC ã‚«ãƒ¼ãƒ‰ï¼ˆSuica/PASMOï¼‰ãŒä¾¿åˆ©ã§ã™ã€‚ä¹—ã‚Šæ›ãˆã¯1å›ã§ã™ã€‚",
              transportDetails: {
                method: "é›»è»Š",
                line: "äº¬æ€¥ç·šâ†’éƒ½å–¶æµ…è‰ç·š",
                transfers: 1,
                walkingTime: "5åˆ†"
              }
            },
            {
              id: "act_2", 
              time: "11:30",
              name: "æµ…è‰å¯ºå‚æ‹",
              location: "æµ…è‰",
              coordinates: { lat: 35.7148, lng: 139.7967 },
              type: "culture",
              description: "645å¹´å‰µå»ºã®æ±äº¬æœ€å¤ã®å¯ºé™¢ã€‚é›·é–€ï¼ˆé¢¨é›·ç¥é–€ï¼‰ã¯æµ…è‰ã®ã‚·ãƒ³ãƒœãƒ«ã§ã€é«˜ã•3.9mã€é‡ã•700kgã®å¤§æç¯ãŒæœ‰åã€‚æœ¬å ‚ã§ã¯è¦³éŸ³æ§˜ã«å‚æ‹ã—ã€ãŠã¿ãã˜ã‚’å¼•ãã“ã¨ãŒã§ãã¾ã™ã€‚",
              estimatedCost: "0 JPY",
              duration: "90",
              rating: 4.8,
              tips: "é›·é–€ã§ã®è¨˜å¿µæ’®å½±ã¯å¿…é ˆï¼æœ¬å ‚ã§ã®ãŠå‚ã‚Šã¯äºŒç¤¼äºŒæ‹æ‰‹ä¸€ç¤¼ã§ã€‚ãŠã¿ãã˜ã¯æ—¥æœ¬èªãƒ»è‹±èªå¯¾å¿œã§ã™ã€‚",
              reviews: [
                {
                  rating: 5,
                  text: "é›·é–€ã®è¿«åŠ›ã«åœ§å€’ã•ã‚Œã¾ã—ãŸã€‚æœ¬å ‚ã§ã®å‚æ‹ã¯å¿ƒãŒæ´—ã‚ã‚Œã‚‹æ€ã„ã§ã—ãŸã€‚",
                  author: "æ–‡åŒ–æ„›å¥½å®¶"
                }
              ]
            },
            {
              id: "act_2_lunch",
              time: "13:00",
              name: "æµ…è‰ä»ŠåŠï¼ˆæ˜¼é£Ÿï¼‰",
              location: "æµ…è‰",
              coordinates: { lat: 35.7142, lng: 139.7965 },
              type: "food",
              description: "æ˜æ²»28å¹´å‰µæ¥­ã®è€èˆ—ã™ãç„¼ãåº—ã€‚æœ€é«˜ç´šã®é»’æ¯›å’Œç‰›ã‚’ä½¿ã£ãŸçµ¶å“ã™ãç„¼ãã§ã€æµ…è‰ã®ä¼çµ±ã®å‘³ã‚’å ªèƒ½ã§ãã¾ã™ã€‚ãƒ©ãƒ³ãƒã‚»ãƒƒãƒˆã¯æ¯”è¼ƒçš„ãƒªãƒ¼ã‚ºãƒŠãƒ–ãƒ«ã€‚",
              estimatedCost: "3,500 JPY",
              duration: "60",
              rating: 4.7,
              tips: "ãƒ©ãƒ³ãƒã®ã€Œã™ãç„¼ãå¾¡è†³ã€ãŒãŠã™ã™ã‚ã€‚å¤œã‚ˆã‚Šæ‰‹é ƒãªä¾¡æ ¼ã§æœ¬æ ¼çš„ãªå‘³ã‚’æ¥½ã—ã‚ã¾ã™ã€‚",
              reviews: [
                {
                  rating: 5,
                  text: "ãŠè‚‰ãŒå£ã®ä¸­ã§ã¨ã‚ã‘ã¾ã—ãŸã€‚è€èˆ—ã®æ ¼å¼ã¨å‘³ã«æ„Ÿå‹•ï¼",
                  author: "ã‚°ãƒ«ãƒ¡æ¢æ¤œå®¶"
                }
              ]
            },
            {
              id: "act_3",
              time: "14:00", 
              name: "ä»²è¦‹ä¸–é€šã‚Šæ•£ç­–",
              location: "æµ…è‰",
              coordinates: { lat: 35.7148, lng: 139.7967 },
              type: "shopping",
              description: "æ±Ÿæˆ¸æ™‚ä»£ã‹ã‚‰ç¶šãæ—¥æœ¬æœ€å¤ã®å•†åº—è¡—ï¼ˆç´„250mï¼‰ã€‚89åº—èˆ—ãŒè»’ã‚’é€£ã­ã€äººå½¢ç„¼ãã€é›·ãŠã“ã—ã€æ‰‡å­ã€æ‰‹ã¬ãã„ãªã©ä¼çµ±çš„ãªå’Œé›‘è²¨ã¨ã‚°ãƒ«ãƒ¡ãŒæ¥½ã—ã‚ã¾ã™ã€‚",
              estimatedCost: "2,500 JPY",
              duration: "120",
              rating: 4.6,
              tips: "äººå½¢ç„¼ãã¯ã€Œæœ¨æ‘å®¶æœ¬åº—ã€ã€é›·ãŠã“ã—ã¯ã€Œå¸¸ç›¤å ‚ã€ãŒè€èˆ—ã€‚é£Ÿã¹æ­©ãã—ãªãŒã‚‰å®è”µé–€ã¾ã§æ­©ãã¾ã—ã‚‡ã†ã€‚",
              reviews: [
                {
                  rating: 4,
                  text: "äººå½¢ç„¼ãã®å‡ºæ¥ç«‹ã¦ãŒæœ€é«˜ï¼ãŠåœŸç”£é¸ã³ã‚‚æ¥½ã—ã‹ã£ãŸã§ã™ã€‚",
                  author: "ãŠåœŸç”£ãƒãƒ³ã‚¿ãƒ¼"
                }
              ]
            },
            {
              id: "act_4",
              time: "16:30",
              name: "éš…ç”°å·ã‚¯ãƒ«ãƒ¼ã‚º",
              location: "æµ…è‰",
              coordinates: { lat: 35.7101, lng: 139.8107 },
              type: "sightseeing", 
              description: "æµ…è‰ã€œãŠå°å ´é–“ã®æ°´ä¸Šãƒã‚¹ã€‚éš…ç”°å·ã‹ã‚‰è¦‹ã‚‹æ±äº¬ã‚¹ã‚«ã‚¤ãƒ„ãƒªãƒ¼ï¼ˆ634mï¼‰ã€ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒ–ãƒªãƒƒã‚¸ã€12ã®æ­´å²çš„ãªæ©‹æ¢ã‚’æ°´ä¸Šã‹ã‚‰çœºã‚ã‚‹40åˆ†ã®èˆ¹æ—…ã€‚",
              estimatedCost: "1040 JPY",
              duration: "40",
              rating: 4.7,
              tips: "å³å´ã®å¸­ãŒãŠã™ã™ã‚ï¼æ±äº¬ã‚¹ã‚«ã‚¤ãƒ„ãƒªãƒ¼ãŒã‚ˆãè¦‹ãˆã¾ã™ã€‚èˆ¹å†…ã‚¢ãƒŠã‚¦ãƒ³ã‚¹ã¯æ—¥è‹±å¯¾å¿œã€‚",
              reviews: [
                {
                  rating: 5,
                  text: "æ°´ä¸Šã‹ã‚‰è¦‹ã‚‹æ±äº¬ã¯åˆ¥ä¸–ç•Œï¼ã‚¹ã‚«ã‚¤ãƒ„ãƒªãƒ¼ã®è¿«åŠ›ã«æ„Ÿå‹•ã—ã¾ã—ãŸã€‚",
                  author: "ã‚¯ãƒ«ãƒ¼ã‚ºæ„›å¥½å®¶"
                }
              ]
            },
            {
              id: "act_4_transport",
              time: "17:30",
              name: "ãŠå°å ´ â†’ æµ…è‰é§…",
              location: "ã‚†ã‚Šã‹ã‚‚ã‚ãƒ»éƒ½å–¶æµ…è‰ç·š",
              coordinates: { lat: 35.7101, lng: 139.7956 },
              type: "transport",
              description: "ã‚†ã‚Šã‹ã‚‚ã‚æ–°æ©‹é§…çµŒç”±ã§æµ…è‰é§…ã¾ã§ç´„35åˆ†ã®é›»è»Šç§»å‹•",
              estimatedCost: "320 JPY",
              duration: "35",
              rating: 4.1,
              tips: "ã‚†ã‚Šã‹ã‚‚ã‚ã¯ç„¡äººé‹è»¢ã§æ™¯è‰²ãŒè‰¯ãè¦‹ãˆã¾ã™ã€‚",
              transportDetails: {
                method: "é›»è»Š",
                line: "ã‚†ã‚Šã‹ã‚‚ã‚â†’JRå±±æ‰‹ç·šâ†’éƒ½å–¶æµ…è‰ç·š",
                transfers: 2,
                walkingTime: "8åˆ†"
              }
            },
            {
              id: "act_5",
              time: "18:30",
              name: "è€èˆ—å¤©ã·ã‚‰ã€Œå¤§é»’å®¶ã€ï¼ˆå¤•é£Ÿï¼‰",
              location: "æµ…è‰",
              coordinates: { lat: 35.7145, lng: 139.7962 },
              type: "food",
              description: "1887å¹´å‰µæ¥­ã€137å¹´ã®æ­´å²ã‚’èª‡ã‚‹æ±Ÿæˆ¸å‰å¤©ã·ã‚‰ã®è€èˆ—ã€‚4ä»£ç›®ãŒå®ˆã‚Šç¶šã‘ã‚‹ä¼çµ±ã®æŠ€æ³•ã§ã€è»Šæµ·è€ã€ç©´å­ã€é‡èœã®å¤©ã·ã‚‰ã‚’èƒ¡éº»æ²¹ã§ã‚«ãƒ©ãƒƒã¨æšã’ã¾ã™ã€‚",
              estimatedCost: "4500 JPY", 
              duration: "90",
              rating: 4.8,
              tips: "ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å¸­ã§è·äººã®æŠ€ã‚’é–“è¿‘ã§ï¼æµ·è€å¤©ï¼ˆ1,200å††ï¼‰ã¨ç©´å­å¤©ï¼ˆ1,000å††ï¼‰ã¯çµ¶å¯¾æ³¨æ–‡ã€‚å¤©ã¤ã‚†ã¯ç”˜ã‚ã®æ±Ÿæˆ¸å‰ã‚¹ã‚¿ã‚¤ãƒ«ã€‚",
              reviews: [
                {
                  rating: 5,
                  text: "137å¹´ã®ä¼çµ±ã‚’æ„Ÿã˜ã‚‹æœ¬æ ¼çš„ãªæ±Ÿæˆ¸å‰å¤©ã·ã‚‰ã€‚è·äººã•ã‚“ã®æŠ€è¡“ã«æ„Ÿå‹•ã—ã¾ã—ãŸã€‚",
                  author: "å¤©ã·ã‚‰æ„›å¥½å®¶"
                }
              ]
            }
          ]
        },
        {
          day: 2,
          date: new Date(Date.now() + 86400000).toISOString().split('T')[0],
          title: "æ¸‹è°·ãƒ»åŸå®¿ã‚«ãƒ«ãƒãƒ£ãƒ¼ä½“é¨“",
          activities: [
            {
              id: "act_6",
              time: "09:00",
              name: "æ˜æ²»ç¥å®®å‚æ‹",
              location: "åŸå®¿",
              coordinates: { lat: 35.6763, lng: 139.6993 },
              type: "culture",
              description: "1920å¹´å‰µå»ºã€æ˜æ²»å¤©çš‡ã¨æ˜­æ†²çš‡å¤ªåã‚’ç¥€ã‚‹ç¥ç¤¾ã€‚70ä¸‡ã¡ã®äººå·¥æ—ã€Œæ˜æ²»ç¥å®®ã®æ£®ã€ã«å›²ã¾ã‚Œã€éƒ½å¿ƒã¨ã¯æ€ãˆãªã„é™å¯‚ãªç©ºé–“ã€‚å¹´é–“å‚æ‹è€…æ•°ã¯æ—¥æœ¬ä¸€ã®ç´„1000ä¸‡äººã€‚",
              estimatedCost: "0 JPY",
              duration: "90",
              rating: 4.9,
              tips: "å—å‚é“ï¼ˆåŸå®¿é§…å´ï¼‰ã‹ã‚‰å…¥ã‚‹ã®ãŒä¸€èˆ¬çš„ã€‚å¤§é³¥å±…ã¯æœ¨é€ ã§ã¯æ—¥æœ¬ä¸€ã®å¤§ãã•ã€‚å¾¡æœ±å°ã¯500å††ã§ã™ã€‚",
              reviews: [
                {
                  rating: 5,
                  text: "éƒ½å¿ƒã«ã“ã‚“ãªé™å¯‚ãªæ£®ãŒã‚ã‚‹ã¨ã¯ï¼å¿ƒãŒæ´—ã‚ã‚Œã‚‹ç¥è–ãªä½“é¨“ã§ã—ãŸã€‚",
                  author: "ã‚¹ãƒ”ãƒªãƒãƒ¥ã‚¢ãƒ«æ¢æ±‚è€…"
                }
              ]
            },
            {
              id: "act_6_transport",
              time: "10:45",
              name: "æ˜æ²»ç¥å®®å‰ â†’ ç«¹ä¸‹é€šã‚Š",
              location: "å¾’æ­©ç§»å‹•",
              coordinates: { lat: 35.6702, lng: 139.7016 },
              type: "transport",
              description: "æ˜æ²»ç¥å®®å‰é§…ã‹ã‚‰ç«¹ä¸‹é€šã‚Šå…¥å£ã¾ã§å¾’æ­©3åˆ†ã®çŸ­è·é›¢ç§»å‹•",
              estimatedCost: "0 JPY",
              duration: "3",
              rating: 4.0,
              tips: "JRåŸå®¿é§…ã®ç«¹ä¸‹å£ãŒæœ€å¯„ã‚Šã§ã™ã€‚",
              transportDetails: {
                method: "å¾’æ­©",
                distance: "200m",
                walkingTime: "3åˆ†"
              }
            },
            {
              id: "act_7",
              time: "11:00",
              name: "ç«¹ä¸‹é€šã‚Šæ•£ç­–",
              location: "åŸå®¿",
              coordinates: { lat: 35.6702, lng: 139.7016 },
              type: "shopping",
              description: "å…¨é•·350mã®æ—¥æœ¬ãƒãƒƒãƒ—ã‚«ãƒ«ãƒãƒ£ãƒ¼ã®è–åœ°ã€‚åŸå®¿ç³»ãƒ•ã‚¡ãƒƒã‚·ãƒ§ãƒ³ã€ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚°ãƒƒã‚ºã€ã‚¯ãƒ¬ãƒ¼ãƒ—åº—ãªã©ç´„400åº—èˆ—ãŒå¯†é›†ã€‚é€±æœ«ã¯æ­©è¡Œè€…å¤©å›½ã«ãªã‚Šã¾ã™ã€‚",
              estimatedCost: "3,500 JPY",
              duration: "120",
              rating: 4.5,
              tips: "ã€Œãƒãƒªã‚ªãƒ³ã‚¯ãƒ¬ãƒ¼ãƒ—ã€ã®åŸå®¿ã‚¯ãƒ¬ãƒ¼ãƒ—ï¼ˆ500å††ï¼‰ã¯å¿…é£Ÿï¼ã€ŒDAISOåŸå®¿åº—ã€ã¯100å††ã‚·ãƒ§ãƒƒãƒ—ã®è–åœ°ã§ã™ã€‚",
              reviews: [
                {
                  rating: 4,
                  text: "ã‚«ãƒ©ãƒ•ãƒ«ã§æ¥½ã—ã„ï¼ã‚¯ãƒ¬ãƒ¼ãƒ—ãŒç¾å‘³ã—ãã¦ã€è‹¥è€…ã®æ–‡åŒ–ã‚’æ„Ÿã˜ã‚‰ã‚Œã¾ã—ãŸã€‚",
                  author: "ãƒãƒƒãƒ—ã‚«ãƒ«ãƒãƒ£ãƒ¼ãƒ•ã‚¡ãƒ³"
                }
              ]
            },
            {
              id: "act_7_lunch",
              time: "13:00",
              name: "bills è¡¨å‚é“ï¼ˆæ˜¼é£Ÿï¼‰",
              location: "è¡¨å‚é“",
              coordinates: { lat: 35.6657, lng: 139.7085 },
              type: "food",
              description: "ã‚·ãƒ‰ãƒ‹ãƒ¼ç™ºç¥¥ã®ã€Œä¸–ç•Œä¸€ã®æœé£Ÿã€ã§æœ‰åãªã‚«ãƒ•ã‚§ãƒ¬ã‚¹ãƒˆãƒ©ãƒ³ã€‚ãµã‚ãµã‚ã®ãƒªã‚³ãƒƒã‚¿ãƒ‘ãƒ³ã‚±ãƒ¼ã‚­ã¨ã‚ªãƒ¼ã‚¬ãƒ‹ãƒƒã‚¯é£Ÿæã‚’ä½¿ã£ãŸæ–™ç†ãŒè‡ªæ…¢ã€‚",
              estimatedCost: "2,800 JPY",
              duration: "60",
              rating: 4.6,
              tips: "åç‰©ã®ãƒªã‚³ãƒƒã‚¿ãƒ‘ãƒ³ã‚±ãƒ¼ã‚­ï¼ˆ1,400å††ï¼‰ã¯çµ¶å¯¾æ³¨æ–‡ï¼å¹³æ—¥ãƒ©ãƒ³ãƒã¯æ¯”è¼ƒçš„ç©ºã„ã¦ã„ã¾ã™ã€‚",
              reviews: [
                {
                  rating: 5,
                  text: "ãƒ‘ãƒ³ã‚±ãƒ¼ã‚­ãŒãµã‚ãµã‚ã§æ„Ÿå‹•ï¼ã‚ªãƒ¼ã‚¹ãƒˆãƒ©ãƒªã‚¢ã®å‘³ã‚’æ±äº¬ã§æ¥½ã—ã‚ã¾ã—ãŸã€‚",
                  author: "ãƒ‘ãƒ³ã‚±ãƒ¼ã‚­æ„›å¥½å®¶"
                }
              ]
            },
            {
              id: "act_7_transport",
              time: "14:15",
              name: "è¡¨å‚é“ â†’ è¡¨å‚é“ãƒ’ãƒ«ã‚º",
              location: "å¾’æ­©ç§»å‹•",
              coordinates: { lat: 35.6657, lng: 139.7085 },
              type: "transport",
              description: "è¡¨å‚é“é§…ã‹ã‚‰è¡¨å‚é“ãƒ’ãƒ«ã‚ºã¾ã§å¾’æ­©2åˆ†ã®çŸ­è·é›¢ç§»å‹•",
              estimatedCost: "0 JPY",
              duration: "2",
              rating: 4.0,
              tips: "è¡¨å‚é“ã®ç¾ã—ã„ã‚±ãƒ¤ã‚­ä¸¦æœ¨ã‚’æ¥½ã—ã¿ãªãŒã‚‰æ­©ã‘ã¾ã™ã€‚",
              transportDetails: {
                method: "å¾’æ­©",
                distance: "150m",
                walkingTime: "2åˆ†"
              }
            },
            {
              id: "act_8",
              time: "14:00",
              name: "è¡¨å‚é“ãƒ’ãƒ«ã‚º",
              location: "è¡¨å‚é“",
              coordinates: { lat: 35.6657, lng: 139.7085 },
              type: "shopping",
              description: "å»ºç¯‰å®¶ãƒ»å®‰è—¤å¿ é›„è¨­è¨ˆã®èºæ—‹ã‚¹ãƒ­ãƒ¼ãƒ—ãŒç¾ã—ã„ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°æ–½è¨­ã€‚åœ°ä¸‹3éšã€œåœ°ä¸Š3éšã«ç´„100åº—èˆ—ã€‚åŒæ½¤ä¼šé’å±±ã‚¢ãƒ‘ãƒ¼ãƒˆã®æ­´å²ã‚’å—ã‘ç¶™ãæ–‡åŒ–çš„å»ºç¯‰ç‰©ã€‚",
              estimatedCost: "6,000 JPY",
              duration: "120", 
              rating: 4.6,
              tips: "èºæ—‹ã‚¹ãƒ­ãƒ¼ãƒ—ã¯å»ºç¯‰ç¾ã®å‚‘ä½œï¼å±‹ä¸Šãƒ†ãƒ©ã‚¹ã€Œã‚¹ãƒšãƒ¼ã‚¹ ã‚ªãƒ¼ã€ã‹ã‚‰ã®è¡¨å‚é“ã‚±ãƒ¤ã‚­ä¸¦æœ¨ã®çœºã‚ã¯çµ¶æ™¯ã§ã™ã€‚",
              reviews: [
                {
                  rating: 5,
                  text: "å®‰è—¤å¿ é›„ã®å»ºç¯‰ç¾ã«æ„Ÿå‹•ï¼ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°ã—ãªãŒã‚‰èŠ¸è¡“ä½œå“ã®ä¸­ã‚’æ­©ã„ã¦ã„ã‚‹æ°—åˆ†ã€‚",
                  author: "å»ºç¯‰æ„›å¥½å®¶"
                }
              ]
            },
            {
              id: "act_8_transport",
              time: "16:45",
              name: "è¡¨å‚é“ â†’ æ¸‹è°·",
              location: "JRå±±æ‰‹ç·š",
              coordinates: { lat: 35.6581, lng: 139.7016 },
              type: "transport",
              description: "JRå±±æ‰‹ç·šã§è¡¨å‚é“ã‹ã‚‰æ¸‹è°·ã¾ã§ç´„7åˆ†ã®é›»è»Šç§»å‹•",
              estimatedCost: "160 JPY",
              duration: "7",
              rating: 4.3,
              tips: "å±±æ‰‹ç·šã¯2-4åˆ†é–“éš”ã§é‹è¡Œã€‚ãƒ©ãƒƒã‚·ãƒ¥æ™‚é–“ã‚’é¿ã‘ã¦ã„ã‚‹ã®ã§æ¯”è¼ƒçš„ç©ºã„ã¦ã„ã¾ã™ã€‚",
              transportDetails: {
                method: "é›»è»Š",
                line: "JRå±±æ‰‹ç·š",
                transfers: 0,
                walkingTime: "3åˆ†"
              }
            },
            {
              id: "act_9",
              time: "16:30", 
              name: "æ¸‹è°·ã‚¹ã‚«ã‚¤å±•æœ›å°",
              location: "æ¸‹è°·",
              coordinates: { lat: 35.6581, lng: 139.7016 },
              type: "sightseeing",
              description: "æ¸‹è°·ã‚¹ã‚«ã‚¤ãƒ“ãƒ«å±‹ä¸Šã®360åº¦ãƒ‘ãƒãƒ©ãƒå±•æœ›å°ï¼ˆåœ°ä¸Š230mï¼‰ã€‚ä¸–ç•Œæœ€å¤§ç´šã®ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«äº¤å·®ç‚¹ã‚’ä¸Šã‹ã‚‰è¦‹ä¸‹ã‚ã—ã€æ™´å¤©æ™‚ã¯å¯Œå£«å±±ã€æ±äº¬ã‚¹ã‚«ã‚¤ãƒ„ãƒªãƒ¼ã¾ã§ä¸€æœ›ã€‚",
              estimatedCost: "2000 JPY",
              duration: "60",
              rating: 4.7,
              tips: "å¤•æ—¥ã‚¿ã‚¤ãƒ ï¼ˆ17:00-18:30ï¼‰ãŒãƒ™ã‚¹ãƒˆï¼ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«äº¤å·®ç‚¹ã®äººã®æµã‚Œã¯åœ§å·»ã€‚å†™çœŸæ’®å½±ã‚¹ãƒãƒƒãƒˆå¤šæ•°ã€‚",
              reviews: [
                {
                  rating: 5,
                  text: "ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«äº¤å·®ç‚¹ã‚’ä¸Šã‹ã‚‰è¦‹ã‚‹ä½“é¨“ã¯å”¯ä¸€ç„¡äºŒï¼å¤•æ—¥ã¨æ±äº¬ã®å¤œæ™¯ãŒæœ€é«˜ã§ã—ãŸã€‚",
                  author: "çµ¶æ™¯ãƒãƒ³ã‚¿ãƒ¼"
                }
              ]
            },
            {
              id: "act_9_dinner",
              time: "19:00",
              name: "æ¸‹è°·ã€Œé³¥è²´æ—ã€ï¼ˆå¤•é£Ÿï¼‰",
              location: "æ¸‹è°·",
              coordinates: { lat: 35.6598, lng: 139.7006 },
              type: "food",
              description: "å…¨å“298å††ï¼ˆç¨æŠœï¼‰ã®ç„¼ãé³¥å±…é…’å±‹ãƒã‚§ãƒ¼ãƒ³ã€‚æ–°é®®ãªå›½ç”£é¶ã‚’ä½¿ã£ãŸç„¼ãé³¥ã¨è±Šå¯Œãªãƒ‰ãƒªãƒ³ã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã§ã€æ—¥æœ¬ã®å±…é…’å±‹æ–‡åŒ–ã‚’æ°—è»½ã«ä½“é¨“ã§ãã¾ã™ã€‚",
              estimatedCost: "2,500 JPY",
              duration: "90",
              rating: 4.4,
              tips: "ã€Œã‚‚ã‚‚è²´æ—ç„¼ã€ã¨ã€Œã¤ãã­ã€ã¯å®šç•ªï¼ä¹¾æ¯ã¯ã€Œã‚«ãƒ³ãƒ‘ã‚¤ï¼ã€ã§ã€‚ãƒã‚¤ãƒœãƒ¼ãƒ«ãŒäººæ°—ã§ã™ã€‚",
              reviews: [
                {
                  rating: 4,
                  text: "ãƒªãƒ¼ã‚ºãƒŠãƒ–ãƒ«ã§ç¾å‘³ã—ã„ï¼åœ°å…ƒã®äººãŸã¡ã¨ä¸€ç·’ã«æ¥½ã—ã„æ™‚é–“ã‚’éã”ã›ã¾ã—ãŸã€‚",
                  author: "å±…é…’å±‹æ¢æ¤œå®¶"
                }
              ]
            }
          ]
        }
      ]
    },
    isMockData: true,
    message: "é€šä¿¡ã«å¤±æ•—ã—ãŸãŸã‚ã€ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚"
  };
};

// TripAdvisor Mock Data
export const mockTripAdvisorResponse = (): MockDataResponse => ({
  success: true,
  data: [
    {
      name: "æµ…è‰å¯º",
      description: "645å¹´å‰µå»ºã®æ±äº¬æœ€å¤ã®å¯ºé™¢ã€‚é›·é–€ã€ä»²è¦‹ä¸–é€šã‚Šã€æœ¬å ‚ãªã©è¦‹ã©ã“ã‚æº€è¼‰ã€‚å¹´é–“ç´„3000ä¸‡äººãŒè¨ªã‚Œã‚‹æ±äº¬å±ˆæŒ‡ã®è¦³å…‰åæ‰€ã§ã™ã€‚",
      rating: "4.5",
      num_reviews: "15,000+",
      photo: {
        images: {
          original: {
            url: "https://images.pexels.com/photos/161251/senso-ji-temple-asakusa-tokyo-japan-161251.jpeg"
          }
        }
      },
      web_url: "https://www.tripadvisor.com/Attraction_Review-g1066451-d320046-Reviews-Senso_ji_Temple-Taito_Tokyo_Tokyo_Prefecture_Kanto.html"
    },
    {
      name: "æ˜æ²»ç¥å®®",
      description: "æ˜æ²»å¤©çš‡ã¨æ˜­æ†²çš‡å¤ªåã‚’ç¥€ã‚‹ç¥ç¤¾ã€‚éƒ½å¿ƒã«ã‚ã‚ŠãªãŒã‚‰70ä¸‡å¹³æ–¹ãƒ¡ãƒ¼ãƒˆãƒ«ã®æ·±ã„æ£®ã«å›²ã¾ã‚ŒãŸç¥è–ãªç©ºé–“ã§ã™ã€‚",
      rating: "4.9",
      num_reviews: "12,000+",
      photo: {
        images: {
          original: {
            url: "https://images.pexels.com/photos/2070033/pexels-photo-2070033.jpeg"
          }
        }
      },
      web_url: "https://www.tripadvisor.com/Attraction_Review-g1066456-d320047-Reviews-Meiji_Shrine-Shibuya_Tokyo_Tokyo_Prefecture_Kanto.html"
    }
  ],
  reviews: {
    data: [
      {
        title: "æ—©æœå‚æ‹ãŒæœ€é«˜ã§ã—ãŸ",
        text: "æœ6æ™‚ã«è¨ªã‚Œã¾ã—ãŸãŒã€è¦³å…‰å®¢ã‚‚å°‘ãªãé™å¯‚ãªé›°å›²æ°—ã®ä¸­ã§å‚æ‹ã§ãã¾ã—ãŸã€‚é›·é–€ã‹ã‚‰æœ¬å ‚ã¾ã§ã®é“ã®ã‚Šã§æ—¥æœ¬ã®æ­´å²ã‚’æ„Ÿã˜ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚",
        rating: 5,
        user: { username: "TokyoMorningWalker" }
      },
      {
        title: "ä»²è¦‹ä¸–é€šã‚Šã®ã‚°ãƒ«ãƒ¡ãŒæœ€é«˜",
        text: "äººå½¢ç„¼ãã¨é›·ãŠã“ã—ã‚’é£Ÿã¹æ­©ãã—ã¾ã—ãŸã€‚ã©ã¡ã‚‰ã‚‚å‡ºæ¥ç«‹ã¦ã§ç¾å‘³ã—ãã€ãŠåœŸç”£ã«ã‚‚æœ€é©ã§ã™ã€‚å¤–å›½äººè¦³å…‰å®¢ã«ã‚‚å„ªã—ã„ãŠåº—ãŒå¤šã„ã§ã™ã€‚",
        rating: 4,
        user: { username: "FoodieExplorer" }
      },
      {
        title: "å¤œã®ãƒ©ã‚¤ãƒˆã‚¢ãƒƒãƒ—ã‚‚ç¾ã—ã„",
        text: "æ˜¼é–“ã¨ã¯é•ã£ãŸå¹»æƒ³çš„ãªé›°å›²æ°—ã‚’æ¥½ã—ã‚ã¾ã™ã€‚äº”é‡å¡”ã®ãƒ©ã‚¤ãƒˆã‚¢ãƒƒãƒ—ã¯ç‰¹ã«å°è±¡çš„ã§ã—ãŸã€‚",
        rating: 5,
        user: { username: "NightPhotographer" }
      }
    ]
  },
  isMockData: true,
  message: "é€šä¿¡ã«å¤±æ•—ã—ãŸãŸã‚ã€ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚"
});

// Google Maps Mock Data
export const mockGoogleMapsResponse = (): MockDataResponse => ({
  success: true,
  data: [
    {
      id: "place_1",
      name: "æµ…è‰å¯º",
      nameEn: "Senso-ji Temple",
      category: "temple",
      rating: 4.8,
      distance: "0.5km",
      address: "æ±äº¬éƒ½å°æ±åŒºæµ…è‰2-3-1",
      phone: "03-3842-0181",
      hours: "6:00-17:00",
      description: "æ±äº¬æœ€å¤ã®å¯ºé™¢",
      image: "https://images.pexels.com/photos/161251/senso-ji-temple-asakusa-tokyo-japan-161251.jpeg"
    },
    {
      id: "place_2",
      name: "æ±äº¬ã‚¹ã‚«ã‚¤ãƒ„ãƒªãƒ¼",
      nameEn: "Tokyo Skytree", 
      category: "landmark",
      rating: 4.7,
      distance: "1.2km",
      address: "æ±äº¬éƒ½å¢¨ç”°åŒºæŠ¼ä¸Š1-1-2",
      phone: "0570-55-0634",
      hours: "8:00-22:00",
      description: "ä¸–ç•Œä¸€é«˜ã„é›»æ³¢å¡”",
      image: "https://images.pexels.com/photos/2070033/pexels-photo-2070033.jpeg"
    }
  ],
  predictions: [
    {
      structured_formatting: { main_text: "æµ…è‰å¯º" },
      description: "æ±äº¬éƒ½å°æ±åŒºæµ…è‰2-3-1, æ—¥æœ¬",
      place_id: "mock_asakusa_temple",
      types: ["place_of_worship", "tourist_attraction"]
    },
    {
      structured_formatting: { main_text: "æ±äº¬ã‚¹ã‚«ã‚¤ãƒ„ãƒªãƒ¼" },
      description: "æ±äº¬éƒ½å¢¨ç”°åŒºæŠ¼ä¸Š1-1-2, æ—¥æœ¬", 
      place_id: "mock_tokyo_skytree",
      types: ["tourist_attraction", "point_of_interest"]
    }
  ],
  isMockData: true,
  message: "é€šä¿¡ã«å¤±æ•—ã—ãŸãŸã‚ã€ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚"
});

// eSIM Mock Data
export const mockESIMResponse = (): MockDataResponse => ({
  success: true,
  data: [
    {
      id: "esim_plan_1",
      name: "Japan 3GB - 15 Days",
      description: "æ—¥æœ¬å…¨å›½ã§ä½¿ãˆã‚‹15æ—¥é–“3GBãƒ—ãƒ©ãƒ³",
      dataAmount: "3GB",
      validity: "15æ—¥",
      price: { amount: 3500, currency: "JPY" },
      coverage: "æ—¥æœ¬å…¨å›½",
      network: "NTT Docomo"
    },
    {
      id: "esim_plan_2", 
      name: "Japan 10GB - 30 Days",
      description: "æ—¥æœ¬å…¨å›½ã§ä½¿ãˆã‚‹30æ—¥é–“10GBãƒ—ãƒ©ãƒ³",
      dataAmount: "10GB",
      validity: "30æ—¥",
      price: { amount: 8500, currency: "JPY" },
      coverage: "æ—¥æœ¬å…¨å›½",
      network: "NTT Docomo"
    },
    {
      id: "esim_plan_3",
      name: "Japan 1GB - 7 Days", 
      description: "çŸ­æœŸæ»åœ¨å‘ã‘7æ—¥é–“1GBãƒ—ãƒ©ãƒ³",
      dataAmount: "1GB",
      validity: "7æ—¥",
      price: { amount: 1500, currency: "JPY" },
      coverage: "æ—¥æœ¬å…¨å›½",
      network: "SoftBank"
    }
  ],
  isMockData: true,
  message: "é€šä¿¡ã«å¤±æ•—ã—ãŸãŸã‚ã€ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚"
});

// Amadeus Mock Data
export const mockAmadeusResponse = (): MockDataResponse => ({
  success: true,
  data: {
    flights: [
      {
        id: "flight_1",
        airline: "JAL",
        flightNumber: "JL123",
        departure: {
          airport: "NRT",
          city: "Tokyo",
          time: "09:30"
        },
        arrival: {
          airport: "KIX", 
          city: "Osaka",
          time: "11:00"
        },
        price: { amount: 15000, currency: "JPY" },
        duration: "1h 30m"
      }
    ],
    hotels: [
      {
        id: "hotel_1",
        name: "ã‚°ãƒ©ãƒ³ãƒ‰ãƒ›ãƒ†ãƒ«æ±äº¬",
        location: "æ±äº¬é§…å‘¨è¾º",
        rating: 4.5,
        price: { amount: 25000, currency: "JPY" },
        amenities: ["WiFi", "æœé£Ÿ", "æ¸©æ³‰", "ã‚¸ãƒ "]
      }
    ]
  },
  isMockData: true,
  message: "é€šä¿¡ã«å¤±æ•—ã—ãŸãŸã‚ã€ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚"
});

// Currency Convert Mock Data
export const mockCurrencyResponse = (): MockDataResponse => ({
  success: true,
  data: {
    rates: {
      "USD": 0.0067,
      "EUR": 0.0063,
      "GBP": 0.0054,
      "CNY": 0.048,
      "KRW": 9.2,
      "THB": 0.23
    },
    base: "JPY",
    date: new Date().toISOString().split('T')[0]
  },
  isMockData: true,
  message: "é€šä¿¡ã«å¤±æ•—ã—ãŸãŸã‚ã€ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚"
});

// Stripe Mock Data
export const mockStripeResponse = (): MockDataResponse => ({
  success: true,
  data: {
    sessionUrl: "#mock-checkout-session",
    sessionId: "mock_session_123"
  },
  isMockData: true,
  message: "é€šä¿¡ã«å¤±æ•—ã—ãŸãŸã‚ã€ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚æ±ºæ¸ˆæ©Ÿèƒ½ã¯ç¾åœ¨åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚"
});

// Get mock data by endpoint
export const getMockDataByEndpoint = (endpoint: string): MockDataResponse => {
  switch (endpoint) {
    case '/openai-chat':
      return mockChatResponse();
    case '/openai-vision':
      return mockVisionResponse();
    case '/openai-generate':
      return mockGenerateResponse();
    case '/tripadvisor':
      return mockTripAdvisorResponse();
    case '/google-maps':
    case '/google-places':
      return mockGoogleMapsResponse();
    case '/esim':
      return mockESIMResponse();
    case '/amadeus':
      return mockAmadeusResponse();
    case '/currency-convert':
      return mockCurrencyResponse();
    case '/create-checkout-session':
    case '/verify-payment':
      return mockStripeResponse();
    default:
      return {
        success: false,
        data: null,
        isMockData: true,
        message: "é€šä¿¡ã«å¤±æ•—ã—ãŸãŸã‚ã€ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚"
      };
  }
};
</file>

<file path="src/utils/errorHandler.ts">
// TRIPPIN - Comprehensive Error Handling System
import { APIError } from '../config/api';

export interface ErrorLog {
  id: string;
  timestamp: Date;
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  type: string;
  message: string;
  context: ErrorContext;
  stack?: string;
  apiError?: APIError;
}

export interface ErrorContext {
  page: string;
  userId?: string;
  action: string;
  userAgent: string;
  url: string;
}

export interface ValidationError {
  field: string;
  message: string;
  action: string;
}

// AWS API Gateway Error Handling
export const handleAWSError = (error: APIError) => {
  switch (error.code) {
    case 'NETWORK_OFFLINE':
      return {
        message: 'ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šãŒã‚ã‚Šã¾ã›ã‚“ã€‚Wi-Fiã¾ãŸã¯ãƒ¢ãƒã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
        action: 'check_connection',
        severity: 'HIGH'
      };
    case 'NETWORK_ERROR':
      return {
        message: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
        action: 'retry_connection',
        severity: 'MEDIUM'
      };
    case 'TIMEOUT':
      return {
        message: 'ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        action: 'retry_request',
        severity: 'MEDIUM'
      };
    case 'RATE_LIMITED':
      return {
        message: 'ã‚¢ã‚¯ã‚»ã‚¹ãŒé›†ä¸­ã—ã¦ã„ã¾ã™ã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰ãŠè©¦ã—ãã ã•ã„ã€‚',
        action: 'wait_and_retry',
        severity: 'LOW',
        waitTime: '30ç§’'
      };
    case 'UNAUTHORIZED':
      return {
        message: 'èªè¨¼ãŒå¿…è¦ã§ã™ã€‚ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚',
        action: 'redirect_login',
        severity: 'HIGH'
      };
    case 'FORBIDDEN':
      return {
        message: 'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ—ãƒ©ãƒ³ã«ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ãŒå¿…è¦ãªå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚',
        action: 'check_permissions',
        severity: 'HIGH'
      };
    case 'NOT_FOUND':
      return {
        message: 'ãƒªã‚¯ã‚¨ã‚¹ãƒˆã•ã‚ŒãŸã‚µãƒ¼ãƒ“ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚',
        action: 'check_endpoint',
        severity: 'MEDIUM'
      };
    case 'INTERNAL_SERVER_ERROR':
    case 'BAD_GATEWAY':
    case 'SERVICE_UNAVAILABLE':
    case 'GATEWAY_TIMEOUT':
      return {
        message: 'ã‚µãƒ¼ãƒãƒ¼ã§å•é¡ŒãŒç™ºç”Ÿã—ã¦ã„ã¾ã™ã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰ãŠè©¦ã—ãã ã•ã„ã€‚',
        action: 'retry_later',
        severity: 'HIGH',
        waitTime: '5åˆ†'
      };
    default:
      return {
        message: 'äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚µãƒãƒ¼ãƒˆã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚',
        action: 'contact_support',
        severity: 'HIGH'
      };
  }
};

// Auth0 Error Handling
export interface AuthError {
  code: string;
  description: string;
  statusCode: number;
}

export const handleAuthError = (error: AuthError) => {
  switch (error.code) {
    case 'access_denied':
      return {
        message: 'ãƒ­ã‚°ã‚¤ãƒ³ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        action: 'retry_login'
      };
    case 'invalid_request':
      return {
        message: 'èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’æ›´æ–°ã—ã¦ãã ã•ã„ã€‚',
        action: 'refresh_page'
      };
    case 'temporarily_unavailable':
      return {
        message: 'èªè¨¼ã‚µãƒ¼ãƒãƒ¼ãŒä¸€æ™‚çš„ã«åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ãŠè©¦ã—ãã ã•ã„ã€‚',
        action: 'retry_later'
      };
    case 'network_error':
      return {
        message: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
        action: 'check_connection'
      };
    default:
      return {
        message: 'èªè¨¼ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚µãƒãƒ¼ãƒˆã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚',
        action: 'contact_support'
      };
  }
};

// Stripe Payment Error Handling
export const handleStripeError = (error: any) => {
  switch (error.code) {
    case 'card_declined':
      return {
        message: 'ã‚«ãƒ¼ãƒ‰ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚åˆ¥ã®ã‚«ãƒ¼ãƒ‰ã‚’ãŠè©¦ã—ãã ã•ã„ã€‚',
        action: 'retry_payment'
      };
    case 'insufficient_funds':
      return {
        message: 'æ®‹é«˜ä¸è¶³ã§ã™ã€‚ã‚«ãƒ¼ãƒ‰ã®åˆ©ç”¨å¯èƒ½é¡ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
        action: 'change_card'
      };
    case 'expired_card':
      return {
        message: 'ã‚«ãƒ¼ãƒ‰ã®æœ‰åŠ¹æœŸé™ãŒåˆ‡ã‚Œã¦ã„ã¾ã™ã€‚',
        action: 'update_card'
      };
    case 'processing_error':
      return {
        message: 'æ±ºæ¸ˆå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ãŠè©¦ã—ãã ã•ã„ã€‚',
        action: 'retry_later'
      };
    case 'rate_limit':
      return {
        message: 'ä¸€æ™‚çš„ã«ã‚¢ã‚¯ã‚»ã‚¹ãŒé›†ä¸­ã—ã¦ã„ã¾ã™ã€‚ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚',
        action: 'wait_retry'
      };
    default:
      return {
        message: 'æ±ºæ¸ˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚µãƒãƒ¼ãƒˆã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚',
        action: 'contact_support'
      };
  }
};

// ESIMGO API Error Handling
export const handleESIMError = (error: any) => {
  switch (error.code) {
    case 'insufficient_inventory':
      return {
        message: 'é¸æŠã•ã‚ŒãŸãƒ—ãƒ©ãƒ³ã¯ç¾åœ¨åœ¨åº«åˆ‡ã‚Œã§ã™ã€‚ä»–ã®ãƒ—ãƒ©ãƒ³ã‚’ãŠè©¦ã—ãã ã•ã„ã€‚',
        action: 'show_alternatives'
      };
    case 'unsupported_device':
      return {
        message: 'ãŠä½¿ã„ã®ãƒ‡ãƒã‚¤ã‚¹ã¯eSIMã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚',
        action: 'show_device_compatibility'
      };
    case 'activation_failed':
      return {
        message: 'eSIMã®æœ‰åŠ¹åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚è¨­å®šæ‰‹é †ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
        action: 'show_setup_guide'
      };
    case 'network_not_available':
      return {
        message: 'é¸æŠã•ã‚ŒãŸåœ°åŸŸã§ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚',
        action: 'show_coverage_map'
      };
    default:
      return {
        message: 'eSIMã‚µãƒ¼ãƒ“ã‚¹ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚',
        action: 'contact_support'
      };
  }
};

// Amadeus API Error Handling
export const handleAmadeusError = (error: any) => {
  switch (error.code) {
    case 'SOLD_OUT':
      return {
        message: 'é¸æŠã•ã‚ŒãŸãƒ•ãƒ©ã‚¤ãƒˆ/ãƒ›ãƒ†ãƒ«ã¯æº€å¸­/æº€å®¤ã§ã™ã€‚',
        action: 'show_alternatives'
      };
    case 'PRICE_CHANGED':
      return {
        message: 'æ–™é‡‘ãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚æœ€æ–°ã®æ–™é‡‘ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
        action: 'refresh_prices'
      };
    case 'BOOKING_TIMEOUT':
      return {
        message: 'äºˆç´„ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        action: 'restart_booking'
      };
    case 'INVALID_PASSENGER_INFO':
      return {
        message: 'ä¹—å®¢æƒ…å ±ã«ä¸å‚™ãŒã‚ã‚Šã¾ã™ã€‚å…¥åŠ›å†…å®¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
        action: 'validate_passenger_info'
      };
    default:
      return {
        message: 'äºˆç´„ã‚µãƒ¼ãƒ“ã‚¹ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚',
        action: 'contact_support'
      };
  }
};

// OpenAI API Error Handling
export const handleOpenAIError = (error: any) => {
  // Handle AWS Lambda timeout
  if (error.code === 'TIMEOUT' || error.status === 504) {
    return {
      message: 'AIå‡¦ç†ã«æ™‚é–“ãŒã‹ã‹ã£ã¦ã„ã¾ã™ã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰ãŠè©¦ã—ãã ã•ã„ã€‚',
      action: 'retry_with_delay',
      estimatedWait: '1-2åˆ†'
    };
  }
  
  // Handle AWS Lambda cold start
  if (error.status === 502) {
    return {
      message: 'AIæ©Ÿèƒ½ã‚’åˆæœŸåŒ–ä¸­ã§ã™ã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
      action: 'retry_immediately'
    };
  }

  switch (error.code) {
    case 'rate_limit_exceeded':
      return {
        message: 'AIå‡¦ç†ãŒæ··é›‘ã—ã¦ã„ã¾ã™ã€‚ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚',
        action: 'queue_request',
        estimatedWait: '2-3åˆ†'
      };
    case 'insufficient_quota':
      return {
        message: 'AIæ©Ÿèƒ½ãŒä¸€æ™‚çš„ã«åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚',
        action: 'use_fallback_plan'
      };
    case 'invalid_request':
      return {
        message: 'ãƒ—ãƒ©ãƒ³ç”Ÿæˆã«å¿…è¦ãªæƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚',
        action: 'complete_form'
      };
    case 'model_overloaded':
      return {
        message: 'AIæ©Ÿèƒ½ãŒé«˜è² è·ã®ãŸã‚ã€ç°¡æ˜“ãƒ—ãƒ©ãƒ³ã‚’æä¾›ã—ã¾ã™ã€‚',
        action: 'provide_basic_plan'
      };
    default:
      return {
        message: 'AIæ©Ÿèƒ½ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§ãƒ—ãƒ©ãƒ³ã‚’ä½œæˆã—ã¾ã™ã‹ï¼Ÿ',
        action: 'offer_manual_planning'
      };
  }
};

// AWS Lambda specific error handling
export const handleLambdaError = (error: APIError) => {
  if (error.status === 502) {
    return {
      message: 'ã‚µãƒ¼ãƒ“ã‚¹ã‚’åˆæœŸåŒ–ä¸­ã§ã™ã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
      action: 'retry_cold_start'
    };
  }
  
  if (error.status === 504) {
    return {
      message: 'å‡¦ç†ã«æ™‚é–“ãŒã‹ã‹ã£ã¦ã„ã¾ã™ã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰ãŠè©¦ã—ãã ã•ã„ã€‚',
      action: 'retry_with_longer_wait'
    };
  }
  
  return handleAWSError(error);
};

// Network Error Handling
export const handleNetworkError = (error: any) => {
  if (!navigator.onLine) {
    return {
      message: 'ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¦ã„ã¾ã™ã€‚',
      action: 'offline_mode',
      offlineFeatures: ['ä¿å­˜æ¸ˆã¿ãƒ—ãƒ©ãƒ³ç¢ºèª', 'ã‚ªãƒ•ãƒ©ã‚¤ãƒ³åœ°å›³', 'ç·Šæ€¥é€£çµ¡å…ˆ']
    };
  }
  
  switch (error.status) {
    case 408:
    case 504:
      return {
        message: 'ã‚µãƒ¼ãƒãƒ¼ã¸ã®æ¥ç¶šãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚',
        action: 'retry_with_backoff'
      };
    case 429:
      return {
        message: 'ã‚¢ã‚¯ã‚»ã‚¹ãŒé›†ä¸­ã—ã¦ã„ã¾ã™ã€‚ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚',
        action: 'exponential_backoff'
      };
    case 502:
    case 503:
      return {
        message: 'ã‚µãƒ¼ãƒ“ã‚¹ãŒä¸€æ™‚çš„ã«åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚',
        action: 'show_status_page'
      };
    default:
      return {
        message: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚',
        action: 'retry_connection'
      };
  }
};

// Retry with Exponential Backoff
export const retryWithExponentialBackoff = async (
  apiCall: () => Promise<any>,
  maxRetries: number = 3
) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await apiCall();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      const delay = Math.pow(2, i) * 1000; // 1ç§’, 2ç§’, 4ç§’...
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
};

// Data Validation
export const validateTripData = (tripData: any): ValidationError[] => {
  const errors: ValidationError[] = [];
  
  // Date validation
  if (!tripData.startDate || !tripData.endDate) {
    errors.push({
      field: 'dates',
      message: 'å‡ºç™ºæ—¥ã¨å¸°ç€æ—¥ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚',
      action: 'highlight_date_picker'
    });
  }
  
  if (new Date(tripData.startDate) < new Date()) {
    errors.push({
      field: 'startDate',
      message: 'å‡ºç™ºæ—¥ã¯ä»Šæ—¥ä»¥é™ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚',
      action: 'reset_date_picker'
    });
  }
  
  // Budget validation
  if (tripData.budget && tripData.budget < 1000) {
    errors.push({
      field: 'budget',
      message: 'äºˆç®—ã¯1,000å††ä»¥ä¸Šã§è¨­å®šã—ã¦ãã ã•ã„ã€‚',
      action: 'suggest_minimum_budget'
    });
  }
  
  // Region validation
  if (!tripData.regions || tripData.regions.length === 0) {
    errors.push({
      field: 'regions',
      message: 'å°‘ãªãã¨ã‚‚1ã¤ã®åœ°åŸŸã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚',
      action: 'highlight_region_selector'
    });
  }
  
  return errors;
};

// Google Maps API Error Handling
export const handleGoogleMapsError = (error: any) => {
  switch (error.code) {
    case 'ZERO_RESULTS':
      return {
        message: 'æŒ‡å®šã•ã‚ŒãŸå ´æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚',
        action: 'suggest_similar_locations'
      };
    case 'OVER_QUERY_LIMIT':
      return {
        message: 'åœ°å›³ã‚µãƒ¼ãƒ“ã‚¹ãŒä¸€æ™‚çš„ã«åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚',
        action: 'use_static_map'
      };
    case 'REQUEST_DENIED':
      return {
        message: 'åœ°å›³ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚',
        action: 'fallback_to_text_directions'
      };
    default:
      return {
        message: 'åœ°å›³æ©Ÿèƒ½ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚',
        action: 'provide_text_alternative'
      };
  }
};

// TripAdvisor API Error Handling
export const handleTripAdvisorError = (error: any) => {
  switch (error.code) {
    case 'NO_REVIEWS_FOUND':
      return {
        message: 'ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚',
        action: 'show_basic_info'
      };
    case 'LOCATION_NOT_FOUND':
      return {
        message: 'è¦³å…‰åœ°æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚',
        action: 'use_generic_recommendations'
      };
    default:
      return {
        message: 'ãƒ¬ãƒ“ãƒ¥ãƒ¼æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚',
        action: 'skip_reviews'
      };
  }
};

// Integrated Error Management System
export class ErrorHandler {
  private errorQueue: ErrorLog[] = [];
  private maxQueueSize = 50;
  
  handleError(error: APIError | any, context: ErrorContext) {
    const errorLog = this.createErrorLog(error, context);
    
    // Add to queue with size limit
    this.errorQueue.push(errorLog);
    if (this.errorQueue.length > this.maxQueueSize) {
      this.errorQueue = this.errorQueue.slice(-this.maxQueueSize);
    }
    
    // Handle based on severity
    switch (errorLog.severity) {
      case 'CRITICAL':
        this.handleCriticalError(errorLog);
        break;
      case 'HIGH':
        this.handleHighPriorityError(errorLog);
        break;
      case 'MEDIUM':
        this.handleMediumPriorityError(errorLog);
        break;
      case 'LOW':
        this.logError(errorLog);
        break;
    }
  }
  
  private createErrorLog(error: APIError | any, context: ErrorContext): ErrorLog {
    return {
      id: this.generateErrorId(),
      timestamp: new Date(),
      severity: this.determineSeverity(error),
      type: error.code || error.type || 'UNKNOWN',
      message: error.message || 'Unknown error occurred',
      context,
      stack: error.stack,
      apiError: error.status !== undefined ? error as APIError : undefined
    };
  }
  
  private generateErrorId(): string {
    return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  private determineSeverity(error: APIError | any): 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' {
    // AWS/API specific severity
    if (error.status) {
      if ([401, 403, 500, 502, 503].includes(error.status)) {
        return 'HIGH';
      }
      if ([404, 408, 429, 504].includes(error.status)) {
        return 'MEDIUM';
      }
      if ([400].includes(error.status)) {
        return 'LOW';
      }
    }
    
    // Legacy error type handling
    if (error.type === 'PAYMENT_FAILED' || error.type === 'SECURITY_BREACH') {
      return 'CRITICAL';
    }
    if (error.type === 'API_FAILURE' || error.type === 'AUTH_FAILED') {
      return 'HIGH';
    }
    if (error.type === 'VALIDATION_ERROR' || error.type === 'NETWORK_ERROR') {
      return 'MEDIUM';
    }
    return 'LOW';
  }
  
  private handleCriticalError(error: ErrorLog) {
    // Critical errors: payment failures, security issues, auth failures
    this.showErrorModal(error);
    this.sendErrorReport(error);
    this.fallbackToSafeMode();
  }
  
  private handleHighPriorityError(error: ErrorLog) {
    // High priority: server errors, auth issues, service unavailable
    this.showErrorNotification(error);
    this.sendErrorReport(error);
    this.enableFallbackFeatures();
  }
  
  private handleMediumPriorityError(error: ErrorLog) {
    // Medium priority: timeouts, rate limits, not found
    this.showErrorToast(error);
    this.logError(error);
  }
  
  private showErrorModal(error: ErrorLog) {
    // Show modal for critical errors
    console.error('ğŸš¨ Critical Error:', error);
    // In a real app, this would show a modal component
  }
  
  private showErrorNotification(error: ErrorLog) {
    // Show notification for high priority errors
    console.warn('âš ï¸ High Priority Error:', error);
    // In a real app, this would show a notification component
  }
  
  private showErrorToast(error: ErrorLog) {
    // Show toast for medium priority errors
    console.info('â„¹ï¸ Medium Priority Error:', error);
    // In a real app, this would show a toast component
  }
  
  private logError(error: ErrorLog) {
    // Log error for monitoring and debugging
    console.log('ğŸ“ Error logged:', error);
  }
  
  private sendErrorReport(error: ErrorLog) {
    // Send to external monitoring service (CloudWatch, Sentry, etc.)
    try {
      // In production, send to monitoring service
      console.log('ğŸ“Š Sending error report:', error);
    } catch (reportError) {
      console.error('Failed to send error report:', reportError);
    }
  }
  
  private fallbackToSafeMode() {
    // Enable safe mode with limited functionality
    console.log('ğŸ›¡ï¸ Entering safe mode');
    localStorage.setItem('trippin-safe-mode', 'true');
  }
  
  private enableFallbackFeatures() {
    // Enable fallback features when main services fail
    console.log('ğŸ”„ Enabling fallback features');
    localStorage.setItem('trippin-fallback-mode', 'true');
  }
  
  // Get error statistics
  getErrorStats() {
    const now = Date.now();
    const oneHour = 60 * 60 * 1000;
    const recentErrors = this.errorQueue.filter(
      error => now - error.timestamp.getTime() < oneHour
    );
    
    return {
      total: this.errorQueue.length,
      recent: recentErrors.length,
      critical: recentErrors.filter(e => e.severity === 'CRITICAL').length,
      high: recentErrors.filter(e => e.severity === 'HIGH').length,
      medium: recentErrors.filter(e => e.severity === 'MEDIUM').length,
      low: recentErrors.filter(e => e.severity === 'LOW').length
    };
  }
  
  // Clear old errors
  clearOldErrors(maxAge: number = 24 * 60 * 60 * 1000) { // 24 hours
    const cutoff = Date.now() - maxAge;
    this.errorQueue = this.errorQueue.filter(
      error => error.timestamp.getTime() > cutoff
    );
  }
}

// Global error handler instance
export const globalErrorHandler = new ErrorHandler();

// Auto-cleanup old errors every hour
setInterval(() => {
  globalErrorHandler.clearOldErrors();
}, 60 * 60 * 1000);

// Auto Recovery Functions
export const autoRecovery = {
  async handleServiceFailure(service: string) {
    switch (service) {
      case 'openai':
        return this.loadTemplatePlan();
      case 'amadeus':
        return this.getExternalBookingLinks();
      case 'googlemaps':
        return this.getStaticMapImage();
      case 'tripadvisor':
        return this.getBasicAttractionInfo();
      default:
        return this.getBasicFallback();
    }
  },
  
  loadTemplatePlan() {
    // Return template plan when AI is unavailable
    return {
      type: 'template',
      message: 'AIãŒåˆ©ç”¨ã§ããªã„ãŸã‚ã€ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ—ãƒ©ãƒ³ã‚’æä¾›ã—ã¾ã™ã€‚',
      data: {
        destination: 'æ±äº¬',
        duration: '3æ—¥é–“',
        itinerary: [
          {
            day: 1,
            title: 'æ±äº¬åˆ°ç€ãƒ»æµ…è‰æ¢ç´¢',
            activities: [
              { time: '10:00', name: 'æµ…è‰å¯ºå‚æ‹', location: 'æµ…è‰', type: 'culture' },
              { time: '14:00', name: 'ä»²è¦‹ä¸–é€šã‚Šæ•£ç­–', location: 'æµ…è‰', type: 'shopping' }
            ]
          }
        ]
      }
    };
  },
  
  getExternalBookingLinks() {
    // Return external booking links when Amadeus is unavailable
    return {
      type: 'external_links',
      message: 'äºˆç´„ã‚µãƒ¼ãƒ“ã‚¹ãŒåˆ©ç”¨ã§ããªã„ãŸã‚ã€å¤–éƒ¨ã‚µã‚¤ãƒˆã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚',
      links: [
        { name: 'Booking.com', url: 'https://booking.com' },
        { name: 'Expedia', url: 'https://expedia.co.jp' },
        { name: 'ã˜ã‚ƒã‚‰ã‚“', url: 'https://jalan.net' }
      ]
    };
  },
  
  getStaticMapImage() {
    // Return static map when Google Maps is unavailable
    return {
      type: 'static_map',
      message: 'åœ°å›³ãŒåˆ©ç”¨ã§ããªã„ãŸã‚ã€é™çš„ç”»åƒã‚’è¡¨ç¤ºã—ã¾ã™ã€‚',
      mapUrl: 'https://images.pexels.com/photos/2070033/pexels-photo-2070033.jpeg'
    };
  },
  
  getBasicAttractionInfo() {
    return {
      type: 'basic_attraction',
      message: 'è¦³å…‰åœ°æƒ…å ±ãŒåˆ©ç”¨ã§ããªã„ãŸã‚ã€åŸºæœ¬æƒ…å ±ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚',
      data: [
        {
          name: 'æµ…è‰å¯º',
          description: 'æ±äº¬æœ€å¤ã®å¯ºé™¢',
          rating: '4.5',
          photo: { images: { original: { url: 'https://images.pexels.com/photos/161251/senso-ji-temple-asakusa-tokyo-japan-161251.jpeg' } } }
        }
      ]
    };
  },
  
  getBasicFallback() {
    return {
      type: 'basic',
      message: 'ã‚µãƒ¼ãƒ“ã‚¹ãŒä¸€æ™‚çš„ã«åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚åŸºæœ¬æ©Ÿèƒ½ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚',
      availableFeatures: ['ä¿å­˜æ¸ˆã¿ãƒ—ãƒ©ãƒ³ç¢ºèª', 'ã‚ªãƒ•ãƒ©ã‚¤ãƒ³åœ°å›³', 'ç·Šæ€¥é€£çµ¡å…ˆ']
    };
  }
};

// Data Recovery Functions
export const dataRecovery = {
  async recoverUserProgress() {
    // Try localStorage first
    const savedData = localStorage.getItem('trippin_progress');
    if (savedData) {
      return JSON.parse(savedData);
    }
    
    // Try sessionStorage
    const sessionData = sessionStorage.getItem('trippin_session');
    if (sessionData) {
      return JSON.parse(sessionData);
    }
    
    // Try server recovery if authenticated
    const user = JSON.parse(localStorage.getItem('trippin-user') || '{}');
    if (user.id) {
      try {
        // Implement server-side recovery
        return await this.fetchUserProgress(user.id);
      } catch (error) {
        console.error('Server recovery failed:', error);
      }
    }
    
    return null;
  },
  
  async fetchUserProgress(userId: string) {
    // Implement server-side progress recovery
    // This would call your backend API
    return null;
  }
};

// Error Monitoring
export const errorMonitoring = {
  trackError(error: any, context: any) {
    // Track error frequency
    this.incrementErrorCount(error.type);
    
    // Check thresholds
    if (this.isErrorThresholdExceeded(error.type)) {
      this.triggerAlert(error.type);
    }
    
    // Send to monitoring service
    this.sendToMonitoring(error, context);
  },
  
  incrementErrorCount(errorType: string) {
    const counts = JSON.parse(localStorage.getItem('error_counts') || '{}');
    counts[errorType] = (counts[errorType] || 0) + 1;
    localStorage.setItem('error_counts', JSON.stringify(counts));
  },
  
  isErrorThresholdExceeded(errorType: string): boolean {
    const counts = JSON.parse(localStorage.getItem('error_counts') || '{}');
    const threshold = this.getThreshold(errorType);
    return (counts[errorType] || 0) > threshold;
  },
  
  getThreshold(errorType: string): number {
    const thresholds: { [key: string]: number } = {
      'NETWORK_ERROR': 5,
      'API_FAILURE': 3,
      'VALIDATION_ERROR': 10
    };
    return thresholds[errorType] || 5;
  },
  
  triggerAlert(errorType: string) {
    console.warn(`Error threshold exceeded for ${errorType}`);
    // Implement alerting mechanism
  },
  
  sendToMonitoring(error: any, context: any) {
    // Send to external monitoring service
    // Implementation depends on your monitoring setup
    console.log('Sending to monitoring:', { error, context });
  }
};

// Multi-language Error Messages
export const errorMessages = {
  ja: {
    'network_error': 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚',
    'payment_failed': 'æ±ºæ¸ˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚',
    'ai_unavailable': 'AIæ©Ÿèƒ½ãŒä¸€æ™‚çš„ã«åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚',
    'validation_error': 'å…¥åŠ›å†…å®¹ã«å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚',
    'auth_failed': 'èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'
  },
  en: {
    'network_error': 'A network error occurred.',
    'payment_failed': 'Payment failed.',
    'ai_unavailable': 'AI features are temporarily unavailable.',
    'validation_error': 'There is an issue with the input.',
    'auth_failed': 'Authentication failed.'
  },
  zh: {
    'network_error': 'å‘ç”Ÿç½‘ç»œé”™è¯¯ã€‚',
    'payment_failed': 'æ”¯ä»˜å¤±è´¥ã€‚',
    'ai_unavailable': 'AIåŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ã€‚',
    'validation_error': 'è¾“å…¥å†…å®¹æœ‰é—®é¢˜ã€‚',
    'auth_failed': 'è®¤è¯å¤±è´¥ã€‚'
  }
};

export const getLocalizedErrorMessage = (errorKey: string, language: string): string => {
  return errorMessages[language as keyof typeof errorMessages]?.[errorKey] || 
         errorMessages.en[errorKey] || 
         'An error occurred.';
};
</file>

<file path="src/utils/imageOptimizer.ts">
// Image optimization utilities for TRIPPIN
export interface ImageOptimizationOptions {
  maxWidth?: number;
  maxHeight?: number;
  quality?: number;
  format?: 'jpeg' | 'png' | 'webp';
  maxSizeKB?: number;
}

export interface OptimizedImage {
  file: File;
  dataUrl: string;
  originalSize: number;
  optimizedSize: number;
  compressionRatio: number;
}

// Default optimization settings
const DEFAULT_OPTIONS: Required<ImageOptimizationOptions> = {
  maxWidth: 1920,
  maxHeight: 1080,
  quality: 0.8,
  format: 'jpeg',
  maxSizeKB: 500
};

// Supported image formats
const SUPPORTED_FORMATS = ['image/jpeg', 'image/png', 'image/webp'];
const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

export class ImageOptimizer {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;

  constructor() {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d')!;
  }

  // Validate image file
  validateImage(file: File): { valid: boolean; error?: string } {
    if (!file) {
      return { valid: false, error: 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“' };
    }

    if (!SUPPORTED_FORMATS.includes(file.type)) {
      return { 
        valid: false, 
        error: `ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å½¢å¼ã§ã™ã€‚JPEGã€PNGã€WebPã®ã¿å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚` 
      };
    }

    if (file.size > MAX_FILE_SIZE) {
      return { 
        valid: false, 
        error: `ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™ã€‚æœ€å¤§${MAX_FILE_SIZE / 1024 / 1024}MBã¾ã§ã§ã™ã€‚` 
      };
    }

    return { valid: true };
  }

  // Optimize image with given options
  async optimizeImage(
    file: File, 
    options: ImageOptimizationOptions = {}
  ): Promise<OptimizedImage> {
    const validation = this.validateImage(file);
    if (!validation.valid) {
      throw new Error(validation.error);
    }

    const opts = { ...DEFAULT_OPTIONS, ...options };
    
    try {
      // Load image
      const img = await this.loadImage(file);
      
      // Calculate new dimensions
      const { width, height } = this.calculateDimensions(
        img.width, 
        img.height, 
        opts.maxWidth, 
        opts.maxHeight
      );
      
      // Resize and compress
      const optimizedDataUrl = await this.resizeAndCompress(img, width, height, opts);
      
      // Convert back to file
      const optimizedFile = await this.dataUrlToFile(
        optimizedDataUrl, 
        `optimized_${file.name}`,
        opts.format
      );
      
      return {
        file: optimizedFile,
        dataUrl: optimizedDataUrl,
        originalSize: file.size,
        optimizedSize: optimizedFile.size,
        compressionRatio: Math.round((1 - optimizedFile.size / file.size) * 100)
      };
    } catch (error) {
      console.error('Image optimization failed:', error);
      throw new Error('ç”»åƒã®æœ€é©åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }

  // Load image from file
  private loadImage(file: File): Promise<HTMLImageElement> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      const url = URL.createObjectURL(file);
      
      img.onload = () => {
        URL.revokeObjectURL(url);
        resolve(img);
      };
      
      img.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ'));
      };
      
      img.src = url;
    });
  }

  // Calculate optimal dimensions maintaining aspect ratio
  private calculateDimensions(
    originalWidth: number,
    originalHeight: number,
    maxWidth: number,
    maxHeight: number
  ): { width: number; height: number } {
    let { width, height } = { width: originalWidth, height: originalHeight };
    
    // Scale down if too large
    if (width > maxWidth) {
      height = (height * maxWidth) / width;
      width = maxWidth;
    }
    
    if (height > maxHeight) {
      width = (width * maxHeight) / height;
      height = maxHeight;
    }
    
    return { width: Math.round(width), height: Math.round(height) };
  }

  // Resize and compress image
  private async resizeAndCompress(
    img: HTMLImageElement,
    width: number,
    height: number,
    options: Required<ImageOptimizationOptions>
  ): Promise<string> {
    this.canvas.width = width;
    this.canvas.height = height;
    
    // Clear canvas
    this.ctx.clearRect(0, 0, width, height);
    
    // Enable image smoothing for better quality
    this.ctx.imageSmoothingEnabled = true;
    this.ctx.imageSmoothingQuality = 'high';
    
    // Draw resized image
    this.ctx.drawImage(img, 0, 0, width, height);
    
    // Convert to desired format with quality
    const mimeType = `image/${options.format}`;
    let dataUrl = this.canvas.toDataURL(mimeType, options.quality);
    
    // If still too large, reduce quality iteratively
    if (options.maxSizeKB > 0) {
      let quality = options.quality;
      let attempts = 0;
      const maxAttempts = 5;
      
      while (this.getDataUrlSizeKB(dataUrl) > options.maxSizeKB && 
             quality > 0.1 && 
             attempts < maxAttempts) {
        quality -= 0.1;
        dataUrl = this.canvas.toDataURL(mimeType, quality);
        attempts++;
      }
      
      console.log(`[ImageOptimizer] Final quality: ${quality}, attempts: ${attempts}`);
    }
    
    return dataUrl;
  }

  // Get data URL size in KB
  private getDataUrlSizeKB(dataUrl: string): number {
    const base64 = dataUrl.split(',')[1];
    const bytes = (base64.length * 3) / 4;
    return bytes / 1024;
  }

  // Convert data URL back to File
  private async dataUrlToFile(
    dataUrl: string, 
    filename: string,
    format: string
  ): Promise<File> {
    const response = await fetch(dataUrl);
    const blob = await response.blob();
    
    return new File([blob], filename, {
      type: `image/${format}`,
      lastModified: Date.now()
    });
  }

  // Batch optimize multiple images
  async optimizeImages(
    files: File[], 
    options: ImageOptimizationOptions = {}
  ): Promise<OptimizedImage[]> {
    const results: OptimizedImage[] = [];
    
    for (const file of files) {
      try {
        const optimized = await this.optimizeImage(file, options);
        results.push(optimized);
      } catch (error) {
        console.error(`Failed to optimize ${file.name}:`, error);
        // Continue with other files
      }
    }
    
    return results;
  }

  // Create thumbnail
  async createThumbnail(
    file: File,
    size: number = 150
  ): Promise<string> {
    const thumbnailOptions: ImageOptimizationOptions = {
      maxWidth: size,
      maxHeight: size,
      quality: 0.7,
      format: 'jpeg',
      maxSizeKB: 50
    };
    
    const optimized = await this.optimizeImage(file, thumbnailOptions);
    return optimized.dataUrl;
  }

  // Get image metadata
  async getImageMetadata(file: File): Promise<{
    width: number;
    height: number;
    size: number;
    type: string;
    lastModified: number;
  }> {
    const img = await this.loadImage(file);
    
    return {
      width: img.width,
      height: img.height,
      size: file.size,
      type: file.type,
      lastModified: file.lastModified
    };
  }
}

// Singleton instance
export const imageOptimizer = new ImageOptimizer();

// Utility functions
export const optimizeImageFile = async (
  file: File,
  options?: ImageOptimizationOptions
): Promise<OptimizedImage> => {
  return imageOptimizer.optimizeImage(file, options);
};

export const createImageThumbnail = async (
  file: File,
  size?: number
): Promise<string> => {
  return imageOptimizer.createThumbnail(file, size);
};

export const validateImageFile = (file: File) => {
  return imageOptimizer.validateImage(file);
};

// Image format conversion
export const convertImageFormat = async (
  file: File,
  targetFormat: 'jpeg' | 'png' | 'webp'
): Promise<File> => {
  const optimized = await imageOptimizer.optimizeImage(file, {
    format: targetFormat,
    quality: 0.9
  });
  
  return optimized.file;
};

// Progressive image loading helper
export const createProgressiveImage = async (
  file: File
): Promise<{
  thumbnail: string;
  medium: string;
  full: string;
}> => {
  const [thumbnail, medium, full] = await Promise.all([
    imageOptimizer.createThumbnail(file, 150),
    imageOptimizer.optimizeImage(file, { maxWidth: 800, quality: 0.7 }),
    imageOptimizer.optimizeImage(file, { maxWidth: 1920, quality: 0.9 })
  ]);
  
  return {
    thumbnail,
    medium: medium.dataUrl,
    full: full.dataUrl
  };
};
</file>

</files>
